{"tags": ["python", "django", "postgresql"], "comments": [{"score": 3, "creation_date": 1494851796, "post_id": 43979280, "comment_id": 74988412, "body": "What did you try with <code>select_for_update</code>? Try selecting the <code>project</code> instead of the expenses."}, {"score": 0, "creation_date": 1494853801, "post_id": 43979280, "comment_id": 74989809, "body": "@Alasdair That... was a lot simpler than I was expecting. I cannot believe I didn&#39;t think of that. Anyway, could you please add it as an answer so I can accept it."}, {"score": 0, "creation_date": 1494854171, "post_id": 43979280, "comment_id": 74990048, "body": "Glad it helped. If you add an answer with some example code, that would probably be more useful to other users in future than if I just copy my comment."}], "answers": [{"score": 1, "last_activity_date": 1494900868, "answer_id": 43991483, "question_id": 43979280, "body": "<p>Thanks to @Alasdair for pointing me in the right direction.</p>\n\n<p>After filling out the fields of <code>inst</code> (a new <code>Expense</code>), do:</p>\n\n<pre><code>with transaction.atomic():\n    project = models.Project.objects.select_for_update().get(\n        pk=project_id)\n    cost = project.total_cost()\n    budget = project.budget\n\n    if cost + inst.cost &gt; budget:\n        raise forms.ValidationError(_('Over-budget'))\n\n    self._inst.save()\n</code></pre>\n\n<p>Note that I have <code>total_cost</code> defined as a method on <code>Project</code>:</p>\n\n<pre><code>class Project:\n    def total_cost(self):\n        return self.expense_set.all().aggregate(\n            t=Sum(F('cost')))['t']\n</code></pre>\n"}], "is_answered": true, "answer_count": 1, "score": 0, "last_activity_date": 1494900868, "creation_date": 1494850458, "question_id": 43979280, "title": "How to prevent race condition in Django on INSERT with limiting SUM?", "body": "<p>Consider two models:</p>\n\n<ul>\n<li><strong>Project</strong>:\n\n<ul>\n<li>id: An <code>AutoField</code> primary key</li>\n<li>budget: A <code>PositiveIntegerField</code></li>\n<li>some unrelated fields</li>\n</ul></li>\n<li><strong>Expense</strong>\n\n<ul>\n<li>id: An <code>AutoField</code> primary key</li>\n<li>amount: A <code>PositiveIntegerField</code></li>\n<li>project: A <code>ForeignKey</code> to <code>Project</code></li>\n<li>some unrelated fields</li>\n</ul></li>\n</ul>\n\n<p>For each project, I wish to ensure that the sum of their expenses is less than or equal to the budget at all times.</p>\n\n<p>In SQL terms: <code>SELECT SUM(amount) FROM expense WHERE project_id = ?;</code> should always be less than or equal <code>SELECT budget FROM project WHERE id = ?;</code></p>\n\n<p>Is there any way to do this in Django, keeping in mind that multiple people may be accessing the web server and creating <code>Expense</code>s at the same time?</p>\n\n<p>I am using postgresql as my database backend.</p>\n\n<p>I have tried using <code>select_for_update</code> but that doesn't prevent <code>INSERT</code>s from taking place and it doesn't seem to work on aggregations anyway.</p>\n\n<p>I was considering <code>save</code>ing the <code>Expense</code> to the database first, then query the total cost and remove the <code>Expense</code> if it's over-budget but then I would need that code to be outside of a transaction so that other threads can see it and then if the server stops mid-processing, the data could be left in an invalid state.</p>\n"}