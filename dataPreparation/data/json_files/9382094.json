{"tags": ["json", "cxf", "jax-rs", "jackson"], "answers": [{"answer_id": 9382296, "question_id": 9382094, "body": "<p>I think you could trick the filtered writer defining an empty serialize filter for the cases where you want all the properties seralized:</p>\n\n<pre><code>FilterProvider filters = new SimpleFilterProvider().addFilter(\"apiFilter\", SimpleBeanPropertyFilter.serializeAllExcept(emptySet));\n</code></pre>\n\n<p>This way, when the engine looks for the \"apiFilter\" filter defined at the <code>@JsonFilter</code> anotation, it finds it, but it will not have any effect (as will serialize all the properties).</p>\n\n<p><strong>EDIT</strong>\nAlso, you can call the factory method <code>writer()</code> instead of <code>filteredWriter()</code>:</p>\n\n<pre><code>ObjectWriter writer=null;\nif(aplyFilter) {\n    FilterProvider filters = new SimpleFilterProvider().addFilter(\"apiFilter\", SimpleBeanPropertyFilter.filterOutAllExcept(filterProperties));\n    writer=mapper.filteredWriter(filters);\n} else {\n   writer=mapper.writer();\n}\n\nreturn writer.writeValueAsString(user);\n</code></pre>\n\n<p>I think this last solution is way cleaner, and indeed better.</p>\n"}, {"answer_id": 9786215, "question_id": 9382094, "body": "<p>I know it's already been answered but for any newcommers Jackson has actually added the ability to not fail on missing filters (<a href=\"http://jira.codehaus.org/browse/JACKSON-650\">JACKSON-650</a>):<br>\nYou just need to call\n<code>SimpleFilterProvider.setFailOnUnknownId(false)</code> and you won't get this exception.</p>\n"}, {"answer_id": 48643394, "question_id": 9382094, "body": "<p>I had a similar issue getting the same Exception, but the accepted answer didn't really help in my case. Here's the solution that worked for me:</p>\n\n<p>In my setup I was using a custom JacksonSerializer like this:</p>\n\n<pre><code>@JsonSerialize(using = MyCustomSerializer.class)\nprivate Object someAttribute;\n</code></pre>\n\n<p>And that serializer was implemented like this:</p>\n\n<pre><code>public class MyCustomSerializer extends JsonSerializer&lt;Object&gt; {\n  @Override\n  public void serialize(Object o, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {\n    if (o != null) {\n      jgen.writeObject(o);\n    }\n  }\n}\n</code></pre>\n\n<p>The problem with this is, that as long as you don't use any filters, it works. It also works if you serialize primitives, so for instance if you use <code>jgen.writeString(..)</code>. If you use filters, that code is wrong, because the filters are stored somewhere inside of the <code>SerializerProvider</code>, not in the <code>JsonGenerator</code>. If in that case you use the jsongenerator directly, a new SerializerProvider, that doesn't know about the filters, is created internally. So instead of the shorter <code>jgen.writeObject(o)</code> you need to call <code>provider.defaultSerializeValue(o, jgen)</code>. That will ensure that the filters don't get lost and can be applied.</p>\n"}, {"answer_id": 57709992, "question_id": 9382094, "body": "<p>For Spring Boot / Jackson configuration just add:</p>\n\n<pre><code>@Configuration \npublic class JacksonConfiguration { \n    public JacksonConfiguration(ObjectMapper objectMapper) { \n        objectMapper.setFilterProvider(new SimpleFilterProvider().setFailOnUnknownId(false)); \n    } \n}\n</code></pre>\n"}, {"answer_id": 67950184, "question_id": 9382094, "body": "<p>I have applied the same solution as mentioned accepted solution but when i am returning  writer.writeValueAsString(course) as a Rest service response then i am getting response in below format</p>\n<pre><code>{ &quot;status&quot;: &quot;OK&quot;, &quot;data&quot;: &quot;[{\\&quot;name\\&quot;:\\&quot;JPA in Use\\&quot;,\\&quot;reviews\\&quot;:[{\\&quot;id\\&quot;:4081,\\&quot;rating\\&quot;:\\&quot;4\\&quot;,\\&quot;description\\&quot;:\\&quot;Fine\\&quot;},{\\&quot;id\\&quot;:4084,\\&quot;rating\\&quot;:\\&quot;4\\&quot;,\\&quot;description\\&quot;:\\&quot;Ok\\&quot;}]},{\\&quot;name\\&quot;:\\&quot;Spring in Use\\&quot;,\\&quot;reviews\\&quot;:[{\\&quot;id\\&quot;:4003,\\&quot;rating\\&quot;:\\&quot;3\\&quot;,\\&quot;description\\&quot;:\\&quot;Nice Course\\&quot;}]}]&quot; }\n</code></pre>\n<p>But My expected Response is</p>\n<pre><code>{ &quot;status&quot;: &quot;OK&quot;, &quot;data&quot;: [ { &quot;name&quot;: &quot;JPA in Use&quot;, &quot;reviews&quot;: [ { &quot;id&quot;: 4081, &quot;rating&quot;: &quot;4&quot;, &quot;description&quot;: &quot;Fine&quot; }, { &quot;id&quot;: 4082, &quot;rating&quot;: &quot;5&quot;, &quot;description&quot;: &quot;Great&quot; } ] }, { &quot;name&quot;: &quot;Spring in Use&quot;, &quot;reviews&quot;: [ { &quot;id&quot;: 4003, &quot;rating&quot;: &quot;3&quot;, &quot;description&quot;: &quot;Nice Course&quot; } ] } ] }\n</code></pre>\n<p>For getting my response i have applied converted the jsonstring to specfic object type</p>\n<pre><code>List&lt;Course&gt; resultcourse = mapper.readValue(writeValueAsString,List.class);\n</code></pre>\n<p><strong>Note:</strong> Course has id,name and reviews as field and i want to suppress the id</p>\n<p>I am providing the code snippet hope it is helpful to some.</p>\n<pre><code>@GetMapping(&quot;/courses&quot;)\n    public ResponseEntity&lt;JpaResponse&gt; allCourse() throws Exception {\n        JpaResponse response = null;\n         ObjectMapper mapper = new ObjectMapper(); \n         mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        List&lt;Course&gt; course = service.findAllCourse();\n        SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept(&quot;name&quot;,&quot;reviews&quot;);\n        FilterProvider filterProvider = new SimpleFilterProvider().addFilter(&quot;jpafilter&quot;, filter).setFailOnUnknownId(false);\n                ObjectWriter writer = mapper.writer(filterProvider);\n        String writeValueAsString = writer.writeValueAsString(course);\n        List&lt;Course&gt; resultcourse = mapper.readValue(writeValueAsString,List.class);\n            response = new JpaResponse(HttpStatus.OK.name(),resultcourse);\n            return new ResponseEntity&lt;&gt;(response, HttpStatus.OK);\n\n}\n\n\npublic class JpaResponse {\n        private String status;\n        private Object data;\n        public JpaResponse() {\n            super();\n        }\n        public JpaResponse(String status, Object data) {\n            super();\n            this.status = status;\n            this.data = data;\n        }\n}\n</code></pre>\n"}], "is_answered": true, "answer_count": 5, "last_activity_date": 1623510842, "question_id": 9382094, "title": "@JsonFilter throws &quot;JsonMappingException: Can not resolve BeanPropertyFilter&quot;", "body": "<p>Is it possible to selectively determine when the @JsonFilter annotation gets used at runtime?</p>\n\n<p>I'm getting JsonMappingException exception (see below) when I don't provide the filter.</p>\n\n<p><strong>Background:</strong></p>\n\n<p>I learned from a <a href=\"https://stackoverflow.com/questions/9314735/how-to-return-a-partial-json-response-using-java\">recent StackOverflow post</a> that I can use @JsonFilter to dynamically filter the bean properties getting serialized.  This works great.  After adding <code>@JsonFilter(\"apiFilter\")</code> to my domain class and with the addition of this code in my jax-rs service (using the CXF implementation), I am able to dynamically filter the properties returned by my RESTful API:</p>\n\n<pre><code>// shortened for brevity\nFilterProvider filters = new SimpleFilterProvider().addFilter(\"apiFilter\", SimpleBeanPropertyFilter.filterOutAllExcept(filterProperties));\n\nreturn mapper.filteredWriter(filters).writeValueAsString(user);\n</code></pre>\n\n<p>The problem is there are different service calls where I don't want to apply the filter at all.  In those cases I want to return the entire domain class without filtering any properties.  In the case where I just try to return the domain class I'm getting an exception as follows:</p>\n\n<pre><code>Caused by: org.codehaus.jackson.map.JsonMappingException: Can not resolve BeanPropertyFilter with id 'apiFilter'; no FilterProvider configured\n\nat org.codehaus.jackson.map.ser.BeanSerializer.findFilter(BeanSerializer.java:252)\nat org.codehaus.jackson.map.ser.BeanSerializer.serializeFieldsFiltered(BeanSerializer.java:216)\nat org.codehaus.jackson.map.ser.BeanSerializer.serialize(BeanSerializer.java:140)\n</code></pre>\n"}