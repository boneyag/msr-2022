{"tags": ["django", "django-views"], "answers": [{"score": 0, "last_activity_date": 1565172153, "answer_id": 57391825, "question_id": 57391330, "body": "<p>If the form isn't valid, then the form will be re-rendered with errors and you'll get a 200 response.</p>\n\n<p>To debug the problem, check <code>response.context['form'].errors</code> in your test to see what the problem is. </p>\n\n<pre><code>    response = self.client.post(self.edituser_url,\n        data={\n            'first_name': first_name,\n            'last_name': self.last_name,\n            'email': self.email,\n            })\n    print(response.context['form'].errors\n</code></pre>\n\n<p>Your view uses <code>EditUserForm</code>, but you are not posting any values for <code>email1</code> or <code>email2</code>, so there is probably something in the errors about missing data.</p>\n"}], "is_answered": true, "answer_count": 1, "score": 0, "last_activity_date": 1565172153, "creation_date": 1565170692, "question_id": 57391330, "title": "Test UpdateView for useraccounts application", "body": "<p>Test doesn't give status_code 302  in user profile UpdateView and so there's no updates occurs on the object\nthe model code</p>\n\n<pre><code>class User(AbstractBaseUser, PermissionsMixin):\n    '''\n    This a replaced user profile instead of the default django one\n    '''\n    language_choices=[('en',_('English')),('se',_('Swedish'))]\n\n    email=models.CharField(verbose_name=_('Email'), max_length=128, blank=False, unique=True)\n    first_name=models.CharField(verbose_name=_('First Name'), max_length=128)\n    last_name=models.CharField(verbose_name=_('Last Name'), max_length=128)\n    joined_at=models.DateField(\n                                verbose_name=_('Joined at'),\n                                auto_now_add=True,\n                                blank=False\n                                )\n    language=models.CharField(\n                            verbose_name=_('Language'),\n                            max_length=2,\n                            choices=language_choices,\n                            default=language_choices[0][0]\n                            )\n    active=models.BooleanField(verbose_name=_('Active'), default=False)\n    is_superuser=models.BooleanField(verbose_name=_('Is Superuser'), default=False)\n    is_active=models.BooleanField(verbose_name=_('Is Active'), default=True)\n    is_staff=models.BooleanField(verbose_name=_('Is Staff'), default=False)\n</code></pre>\n\n<p>The form code</p>\n\n<pre><code>class EditUserForm(UserChangeForm):\n    '''\n    Profile form to update existing user information\n    '''\n    # error message for email matches\n    error_messages = {\n        'email_mismatch': _(\"The two email fields didn't match.\"),\n        }\n    # create field for email\n    email1 = forms.EmailField(\n        label=_(\"Email\"),\n        widget=forms.EmailInput,\n        help_text=_(\"If you change your email your account will be inactive untill your reactivate by email link.\"),\n    )\n    # get the email from confirmed email field\n    email2 = forms.EmailField(\n        label=_(\"Confirm Email\"),\n        widget=forms.EmailInput,\n        help_text=_(\"Enter the same email as before, for verification.\"),\n    )\n    # hide password field\n    password = ReadOnlyPasswordHashField(label=\"Password\")\n\n    class Meta:\n        '''\n        Initial fields and model for the form\n        '''\n        model = models.User\n        fields = ('first_name','last_name','email1','email2', 'language')\n\n    def clean_email2(self):\n        '''\n        Method for if email and confirmed email are the same\n        This method works when confirmed email cleared\n        '''\n        # get the email from email field\n        email1 = self.cleaned_data.get(\"email1\")\n        # get the email from confirmed email field\n        email2 = self.cleaned_data.get(\"email2\")\n        # check if both emails are equal\n        if email1 and email2 and BaseUserManager.normalize_email(email1) != BaseUserManager.normalize_email(email2):\n            # give an error message if emails not matches\n            raise forms.ValidationError(\n                self.error_messages['email_mismatch'],\n                code='email_mismatch')\n        # return the confirmed email\n        return BaseUserManager.normalize_email(email2)\n\n    def save(self, commit=True):\n        '''\n        Method tosave the edited user data\n        '''\n        # get the initial method\n        user = super().save(commit=False)\n        # set the email on the model field\n        user.email = self.cleaned_data[\"email1\"]\n        # save edited user data\n        if commit:\n            user.save()\n        return user\n\n    def __init__(self, *args, **kwargs):\n        '''\n        Method for initial values and functions for the SignUp form class\n        '''\n        # get user data from User model\n        user = get_user_model().objects.get(email=kwargs['instance'])\n        # get the initial form class values\n        super(EditUserForm, self).__init__(*args, **kwargs)\n        # Add the current email as the inital email\n        self.fields['email1'].initial = user.email\n        # Add the current email as the intial confirmed email\n        self.fields['email2'].initial = user.email\n        # Add help text in the password field for change\n        self.fields['password'].help_text=(\n                    _(\"Raw passwords are not stored, so there is no way to see \"\n                    \"this user's password, but you can change the password \"\n                    \"using &lt;a href=\\\"{0}\\\"&gt;this form&lt;/a&gt;.\")\n                    .format(reverse(\n                        'core:ChangePassword',\n                        kwargs={'pk':user.pk})))\n</code></pre>\n\n<p>and the view code</p>\n\n<pre><code>class EditUser(UserPassesTestMixin, UpdateView):\n    '''\n    Class view to update user details\n    '''\n    # used template\n    template_name = 'core/edit.html'\n    # View model\n    model = models.User\n    # View form\n    form_class = forms.EditUserForm\n\n    def test_func(self):\n        return self.request.user == get_user_model().objects.get(pk=self.kwargs['pk'])\n\n    def get_success_url(self):\n        '''\n        Metho to redirect after a valid form\n        '''\n        # check if the email is verified\n        if self.request.user.active:\n            # get the user key\n            pk=self.request.user.pk\n            # redirect to profile details\n            return reverse_lazy('core:details', kwargs={'pk':pk})\n        else:\n            # send a verification email\n            return SendActivationEmail(self.request, self.request.user)\n</code></pre>\n\n<p>the test code</p>\n\n<pre><code>   self.viewuser_url = reverse('core:details', kwargs={'pk':self.user.pk})\n   self.edituser_url = reverse('core:edit', kwargs={'pk':self.user.pk})\n\ndef test_edit_user_post(self):\n        first_name = 'Osama'\n        response = self.client.post(self.edituser_url,\n            data={\n                'first_name': first_name,\n                'last_name': self.last_name,\n                'email': self.email,\n                })\n\n        self.assertRedirects(response, self.viewuser_url)\n\n        self.user.refresh_from_db()\n\n        self.assertEqual(self.user.first_name, first_name)\n</code></pre>\n\n<p>I tried to get assertEqual for the status code and it gitves me 200 instead of 302</p>\n\n<p>also I tried to enter the form details instead of model details and it gives me an error</p>\n\n<p>The get test works fine and also permission test works great.. all the models, forms and urls test works perfect.</p>\n\n<p>I don't know how I can test this..</p>\n"}