{"tags": ["php", "regex", "string", "preg-replace"], "comments": [{"score": 1, "creation_date": 1620158090, "post_id": 67391294, "comment_id": 119117244, "body": "You could use preg_split with a pattern <code>[\\h-]+</code> to split on spaces and hyphens. <a href=\"https://regex101.com/r/Vg3y1D/1\" rel=\"nofollow noreferrer\">regex101.com/r/Vg3y1D/1</a> See <a href=\"https://3v4l.org/WLcq5\" rel=\"nofollow noreferrer\">3v4l.org/WLcq5</a> So you want to place all the words between <code>&lt;strong&gt;</code>?"}, {"score": 0, "creation_date": 1620160161, "post_id": 67391294, "comment_id": 119118084, "body": "Can you clarify your desired output? Also including the code you&#39;re using, rather than describing it (&quot;which I can repeatedly loop through&quot;) would be helpful for attempting to recreate your results. Based on what I can understand, it seems like <code>preg_replace(&quot;&#47;(\\w+)\\b&#47;i&quot;, &quot;&lt;strong&gt;$1&lt;&#47;strong&gt;&quot;, $My_Text);</code> should work?"}, {"score": 0, "creation_date": 1620161112, "post_id": 67391294, "comment_id": 119118478, "body": "Re: <i>&quot;Can you clarify your desired output? &quot;</i> Thanks, @miken32. I&#39;ve extended the question to include an example string variable, input and output."}], "answers": [{"comments": [{"score": 1, "creation_date": 1620165678, "post_id": 67391572, "comment_id": 119119875, "body": "I very much appreciate your time and work on this, so I&#39;ve upvoted your answer and I want to say thanks."}], "score": 2, "last_activity_date": 1620163142, "last_edit_date": 1620163142, "answer_id": 67391572, "question_id": 67391294, "body": "<p>If you want to match the different strings on spaces or hyphens, you can replace in your <code>$My_String</code> all spaces and hyphens with <code>[\\h-]+</code> to match all consecutive permutations of a space and a hyphen in the source string.</p>\n<p>The character class <code>[\\h-]+</code> matches 1 or more times either a <code>-</code> or a horizontal whitespace char.</p>\n<p>You can wrap the pattern in word boundaries <code>\\b</code> to prevent a partial match.</p>\n<p>If you echo the value of <code>$My_String</code>, the regex would look like this, matching either spaces or hyphens.</p>\n<pre><code>alpha[\\h-]+beta[\\h-]+gamma[\\h-]+delta\n</code></pre>\n<p><a href=\"https://regex101.com/r/j1w5OD/1\" rel=\"nofollow noreferrer\">Regex demo</a> | <a href=\"https://3v4l.org/7OXaZ\" rel=\"nofollow noreferrer\">Php demo</a></p>\n<p>For example</p>\n<pre><code>$My_String = preg_replace(&quot;/[\\h-]+/&quot;, &quot;[\\h-]+&quot;, &quot;alpha beta gamma delta&quot;);\n\n$strings = [\n    &quot;My codephrase is alPha Beta-GaMMa deLTa and your codephrase is ALpha-beTA gAmmA-DElta&quot;,\n    &quot;alpha beta gamma delta&quot;,\n    &quot;alpha-- -- beta    gamma delta&quot;,\n    &quot;alpha beta     gamma-delta&quot;,\n    &quot;alpha beta-gamma delta&quot;,\n    &quot;alpha beta-gamma-delta&quot;,\n    &quot;alpha-beta gamma delta&quot;,\n    &quot;alpha-beta gamma-delta&quot;,\n    &quot;alpha-beta-gamma delta&quot;,\n    &quot;alpha-beta-gamma-delta&quot;,\n    &quot;alpha-beta-gamma-d&quot;\n];\n\nforeach ($strings as $str) {    \n    $str = preg_replace(&quot;/\\b$My_String\\b/i&quot;, &quot;&lt;strong&gt;$0&lt;/strong&gt;&quot;, $str);\n    echo $str . PHP_EOL;\n}\n</code></pre>\n<p>Output</p>\n<pre><code>My codephrase is &lt;strong&gt;alPha Beta-GaMMa deLTa&lt;/strong&gt; and your codephrase is &lt;strong&gt;ALpha-beTA gAmmA-DElta&lt;/strong&gt;\n&lt;strong&gt;alpha beta gamma delta&lt;/strong&gt;\n&lt;strong&gt;alpha-- -- beta    gamma delta&lt;/strong&gt;\n&lt;strong&gt;alpha beta     gamma-delta&lt;/strong&gt;\n&lt;strong&gt;alpha beta-gamma delta&lt;/strong&gt;\n&lt;strong&gt;alpha beta-gamma-delta&lt;/strong&gt;\n&lt;strong&gt;alpha-beta gamma delta&lt;/strong&gt;\n&lt;strong&gt;alpha-beta gamma-delta&lt;/strong&gt;\n&lt;strong&gt;alpha-beta-gamma delta&lt;/strong&gt;\n&lt;strong&gt;alpha-beta-gamma-delta&lt;/strong&gt;\nalpha-beta-gamma-d\n</code></pre>\n"}, {"comments": [{"score": 0, "creation_date": 1620162704, "post_id": 67392212, "comment_id": 119119009, "body": "Ohhhh. This is <i>very</i> clever. So... does this mean the regex parser doesn&#39;t escape regex characters in <code>$My_String</code>? I have to go and try this out right now. If it works, I&#39;m really impressed - this is a very smart workaround."}, {"score": 1, "creation_date": 1620162929, "post_id": 67392212, "comment_id": 119119085, "body": "It does not do any escaping, which can be a problem when you are working with variable patterns. If you have any special characters in <code>$My_String</code> then you would need to escape them before passing to <code>preg_replace()</code>."}, {"score": 0, "creation_date": 1620166309, "post_id": 67392212, "comment_id": 119120054, "body": "Brilliant. You did it. Thank you. I struggled to get <code>str_replace([&quot; &quot;, &quot;-&quot;], &quot;[ -]&quot;, $My_String)</code> to work because it always wanted to parse <code>$My_String</code> twice (presumably once for each element) which led to inner and outer square brackets. But I succeeded with the regex equivalent: <code>preg_replace(&#39;&#47;(.*)[\\s-](.*)&#47;&#39;, &#39;$1[\\s-]$2&#39;, $My_String )</code>."}, {"score": 0, "creation_date": 1620168590, "post_id": 67392212, "comment_id": 119120543, "body": "Using <code>str_replace()</code> is more efficient than running <code>preg_replace()</code>. I&#39;m not sure what kind of trouble you&#39;re describing, but it wasn&#39;t a result of <code>str_replace()</code>."}, {"score": 0, "creation_date": 1620169322, "post_id": 67392212, "comment_id": 119120699, "body": "When I ran <code>str_replace([&quot; &quot;, &quot;-&quot;], &quot;[ -]&quot;, &#39;alpha-beta&#39;)</code>, I got: <code>alpha[ [ -]]beta</code>. We can see what&#39;s happening here: First the <code>-</code> is rewritten as <code>[ -]</code> then, on the second parse, the new <code>-</code> is rewritten as <code>[ -]</code>."}, {"score": 0, "creation_date": 1620653285, "post_id": 67392212, "comment_id": 119256276, "body": "Ahaaa. Thank you for drawing my attention back to this last week, @miken32. You were absolutely right. It turned out I had <i>another</i> unrelated issue - in another, completely separate file - which led to the function being run twice. So, yes, using <code>str_replace()</code> is definitely the optimal approach."}], "score": 1, "last_activity_date": 1620162394, "answer_id": 67392212, "question_id": 67391294, "body": "<p>If you want to treat spaces and hyphens the same, then simply replacing any occurrence of either with <code>[ -]</code> should be sufficient:</p>\n<pre class=\"lang-php prettyprint-override\"><code>$samples = [\n    &quot;My codephrase is alPhA beTa GammA DeLta and your codephrase is aLpHa bEta gAMma delTa&quot;,\n    &quot;My codephrase is alpha beta gamma delta and your codephrase is alpha beta gamma-delta&quot;,\n    &quot;My codephrase is alpha beta-gamma delta and your codephrase is alpha beta-gamma-delta&quot;,\n    &quot;My codephrase is alpha-beta gamma delta and your codephrase is alpha-beta gamma-delta&quot;,\n    &quot;My codephrase is alpha-beta-gamma delta and your codephrase is alpha-beta-gamma-delta&quot;,\n];\n\n$My_String = &quot;alpha beta gamma delta&quot;;\n\n$My_String = str_replace([&quot; &quot;, &quot;-&quot;], &quot;[ -]&quot;, $My_String);\nforeach ($samples as $My_Text) {\n    echo preg_replace(&quot;/\\b($My_String)\\b/i&quot;, &quot;&lt;strong&gt;$1&lt;/strong&gt;&quot;, $My_Text) . &quot;\\n&quot;;\n}\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-html prettyprint-override\"><code>My codephrase is &lt;strong&gt;alPhA beTa GammA DeLta&lt;/strong&gt; and your codephrase is &lt;strong&gt;aLpHa bEta gAMma delTa&lt;/strong&gt;\nMy codephrase is &lt;strong&gt;alpha beta gamma delta&lt;/strong&gt; and your codephrase is &lt;strong&gt;alpha beta gamma-delta&lt;/strong&gt;\nMy codephrase is &lt;strong&gt;alpha beta-gamma delta&lt;/strong&gt; and your codephrase is &lt;strong&gt;alpha beta-gamma-delta&lt;/strong&gt;\nMy codephrase is &lt;strong&gt;alpha-beta gamma delta&lt;/strong&gt; and your codephrase is &lt;strong&gt;alpha-beta gamma-delta&lt;/strong&gt;\nMy codephrase is &lt;strong&gt;alpha-beta-gamma delta&lt;/strong&gt; and your codephrase is &lt;strong&gt;alpha-beta-gamma-delta&lt;/strong&gt;\n</code></pre>\n"}, {"score": 0, "last_activity_date": 1620653578, "last_edit_date": 1620653578, "answer_id": 67392793, "question_id": 67391294, "body": "<p>I owe gratitude to both <code>@TheFourthBird</code> and <code>@miken32</code> for their significant help with this problem.</p>\n<p>Both their answers are excellent and if I could accept both, I would.</p>\n<p>In summary, the correct approach - prior to running <code>preg_replace()</code> - is to take the <code>plaintext</code> string variable and modify it so that it no longer represents a <code>plaintext</code> but a <code>regex</code>, instead.</p>\n<p>In my final approach in the script I'm working on, I successfully replaced:</p>\n<pre><code>preg_replace('/('.$My_String.')/i', '&lt;strong&gt;$1&lt;/strong&gt;', $My_Text);\n</code></pre>\n<p>first with:</p>\n<pre><code>preg_replace('/(' . preg_replace('/(.*)[\\s-](.*)/', '$1[\\s-]$2', $My_String) . ')/i', '&lt;strong&gt;$1&lt;/strong&gt;', $My_Text);\n</code></pre>\n<p>and then - after a bit more prompting from <strong>@miken32</strong> - I was able to create the <code>regex</code> even more efficiently using <code>str_replace</code> as the <em>inner function</em>:</p>\n<pre><code>preg_replace('/(' . str_replace([&quot; &quot;, &quot;-&quot;], &quot;[ -]&quot;, $My_String) . ')/i', '&lt;strong&gt;$1&lt;/strong&gt;', $My_Text);\n</code></pre>\n<p>Without the help from the two members above, it never would have occurred to me that I could <em><strong>nest PHP string replacement functions</strong></em> in this manner.</p>\n"}], "is_answered": true, "answer_count": 3, "score": 1, "last_activity_date": 1620653578, "creation_date": 1620157822, "question_id": 67391294, "title": "Using PHP preg_replace() with a string variable, where the variable needs to represent multiple permutations of itself", "body": "<p>Using:</p>\n<pre><code>preg_replace(pattern, replacement, subject)\n</code></pre>\n<p>I'd like to replace, <em>case-insensitively</em>, the text contained in <code>$My_String</code>, which I can achieve with:</p>\n<pre><code>preg_replace('/('.$My_String.')/i', '&lt;strong&gt;$1&lt;/strong&gt;', $My_Text);\n</code></pre>\n<p>If <code>$My_String</code> is <strong>alpha beta gamma delta</strong>, this will identify:</p>\n<ul>\n<li><em>alPhA beTa GammA DeLta</em></li>\n<li><em>aLpHa bEta gAMma delTa</em></li>\n</ul>\n<p>etc.</p>\n<hr />\n<p>So far, so good. But any <strong>spaces</strong> and <strong>hyphens</strong> in <code>$My_String</code> <em>must also</em> be regarded as equivalent.</p>\n<p>So the <code>preg_replace()</code> function <em>also</em> needs to identify case-insensitive versions of this <strong>entire set</strong>:</p>\n<ul>\n<li>alpha beta gamma delta</li>\n<li>alpha beta gamma-delta</li>\n<li>alpha beta-gamma delta</li>\n<li>alpha beta-gamma-delta</li>\n<li>alpha-beta gamma delta</li>\n<li>alpha-beta gamma-delta</li>\n<li>alpha-beta-gamma delta</li>\n<li>alpha-beta-gamma-delta</li>\n</ul>\n<hr />\n<p>I'm genuinely not sure how to go about this.</p>\n<p>I can get as far as:</p>\n<p><strong>1.</strong> Make a copy of <code>$My_String</code>:</p>\n<pre><code> $My_String_Copy = $My_String\n</code></pre>\n<p><strong>2.</strong> Replace all the spaces with <code>\u00a6</code>:</p>\n<pre><code> $My_String_Copy = str_replace(' ', '\u00a6', $My_String_Copy);\n</code></pre>\n<p><strong>3.</strong> Replace all hyphens with <code>\u00a6</code>:</p>\n<pre><code>$My_String_Copy = str_replace('-', '\u00a6', $My_String_Copy);\n</code></pre>\n<p><strong>4.</strong> Split <code>$My_String_Copy</code> at every occurrence of <code>\u00a6</code>:</p>\n<pre><code>$My_String_Copy_Array = explode('\u00a6', $My_String_Copy);\n</code></pre>\n<p>This will give me an array:</p>\n<pre><code>$My_String_Copy_Array = [\n\n  'Alpha',\n  'Beta',\n  'Gamma',\n  'Delta'\n\n];\n</code></pre>\n<p>Which I can repeatedly loop through to derive the <strong>entire set</strong> above, as an array.</p>\n<p>After that I can run yet another loop, in which, in each iteration, I can run:</p>\n<pre><code>preg_replace('/('.$Entire_Set[$i].')/i', '&lt;strong&gt;$1&lt;/strong&gt;', $My_Text);\n</code></pre>\n<p>targeting, in turn, each element of the <strong>entire set</strong> above.</p>\n<hr />\n<p>That's as far as I've got. But I'm sure there must be a smarter, more efficient way to go about this.</p>\n<p>If I can possibly avoid it, I really <strong>don't want to create an array</strong> containing every single hyphen / space permutation of <code>$My_String</code>.</p>\n<hr />\n<h2>Example Input and Output</h2>\n<p><strong>String Variable:</strong></p>\n<pre><code>$My_String = 'alpha beta gamma delta';\n</code></pre>\n<p><strong>Input:</strong></p>\n<pre class=\"lang-none prettyprint-override\"><code>My codephrase is alPha Beta-GaMMa deLTa and your codephrase is ALpha-beTA gAmmA-DElta.\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre class=\"lang-html prettyprint-override\"><code>My codephrase is &lt;strong&gt;alPha Beta-GaMMa deLTa&lt;/strong&gt; and your codephrase is &lt;strong&gt;ALpha-beTA gAmmA-DElta&lt;/strong&gt;.\n</code></pre>\n"}