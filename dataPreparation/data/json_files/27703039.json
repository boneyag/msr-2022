{"tags": ["ios", "iphone", "regex", "swift", "nsregularexpression"], "comments": [{"score": 1, "creation_date": 1491553886, "post_id": 27703039, "comment_id": 73614639, "body": "I don&#39;t think it really matters, but warning to others: the string in this question with all the letters &amp; numbers has an extra &#39;K&#39; (...JKLKM...). That extra K has propagated through the 4 answers below that also use the string."}], "answers": [{"comments": [{"score": 0, "creation_date": 1419934047, "post_id": 27703112, "comment_id": 43818890, "body": "Thanks for point out. Is it possible to achieve this using Regular expression?"}, {"score": 2, "creation_date": 1470804604, "post_id": 27703112, "comment_id": 65092034, "body": "But what about other languages?"}, {"score": 7, "creation_date": 1470806432, "post_id": 27703112, "comment_id": 65092674, "body": "@nikolsky: You can use <code>NSCharacterSet.alphanumericCharacterSet()</code> to cover alphanumeric characters from all languages."}, {"score": 1, "creation_date": 1470806872, "post_id": 27703112, "comment_id": 65092812, "body": "@MartinR thank you. alphanumericCharacterSet() is definitely more universal then using charactersInString:"}, {"score": 0, "creation_date": 1470807633, "post_id": 27703112, "comment_id": 65093061, "body": "@nikolsky: Yes, but it depends on the application. There may be cases where you only &quot;english&quot; letters and digits are allowed, e.g. for part numbers in an order system. For user names you&#39;ll want to allow &quot;international&quot; letters."}, {"score": 0, "creation_date": 1491873514, "post_id": 27703112, "comment_id": 73734527, "body": "FYI: There is a stray &quot;K&quot; in the capital letters list for both sets. I cannot edit this since it doesn&#39;t change 6 or more characters.."}, {"score": 0, "creation_date": 1517092826, "post_id": 27703112, "comment_id": 83955563, "body": "@MartinR why is there inverted? Is this neccessary?"}, {"score": 0, "creation_date": 1517093936, "post_id": 27703112, "comment_id": 83955819, "body": "@EvgeniyKleban: Yes, because the question was to check if the string contains any special characters. Without inverting the characterset we would test if the string contains any alphanumeric character."}, {"score": 0, "creation_date": 1566898071, "post_id": 27703112, "comment_id": 101790490, "body": "how to check with multiple languages? do i have to add other language char in the given characterset ?"}, {"score": 0, "creation_date": 1597989153, "post_id": 27703112, "comment_id": 112316959, "body": "How about numbers? I want to take them out, but to be able to use all languages?"}], "score": 107, "last_activity_date": 1491881202, "last_edit_date": 1491881202, "answer_id": 27703112, "question_id": 27703039, "body": "<p>Your code check if no character in the string is from the given set.\nWhat you want is to check if <em>any</em> character is <em>not</em> in the given set:</p>\n\n<pre><code>if (searchTerm!.rangeOfCharacterFromSet(characterSet.invertedSet).location != NSNotFound){\n    println(\"Could not handle special characters\")\n}\n</code></pre>\n\n<p>You can also achieve this using regular expressions:</p>\n\n<pre><code>let regex = NSRegularExpression(pattern: \".*[^A-Za-z0-9].*\", options: nil, error: nil)!\nif regex.firstMatchInString(searchTerm!, options: nil, range: NSMakeRange(0, searchTerm!.length)) != nil {\n    println(\"could not handle special characters\")\n\n}\n</code></pre>\n\n<p>The pattern <code>[^A-Za-z0-9]</code> matches a character which is <em>not</em> from the ranges A-Z,\na-z, or 0-9.</p>\n\n<p><strong>Update for Swift 2:</strong></p>\n\n<pre><code>let searchTerm = \"a+b\"\n\nlet characterset = NSCharacterSet(charactersInString: \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\nif searchTerm.rangeOfCharacterFromSet(characterset.invertedSet) != nil {\n    print(\"string contains special characters\")\n}\n</code></pre>\n\n<p><strong>Update for Swift 3:</strong></p>\n\n<pre><code>let characterset = CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\nif searchTerm.rangeOfCharacter(from: characterset.inverted) != nil {\n    print(\"string contains special characters\")\n}\n</code></pre>\n"}, {"comments": [{"score": 0, "creation_date": 1419933450, "post_id": 27703152, "comment_id": 43818585, "body": "Your check is the wrong way around. <i>&quot;Could not handle special characters&quot;</i> is printed if the string contains <i>no</i> special characters."}, {"score": 0, "creation_date": 1419933695, "post_id": 27703152, "comment_id": 43818706, "body": "Now it is correct (and equivalent to the code in my answer, which for some reason was downvoted :)"}, {"score": 0, "creation_date": 1419933751, "post_id": 27703152, "comment_id": 43818728, "body": "@MartinR&gt; I don&#39;t know. but yes yours and my solution is same. You got 2 upvotes though. :P"}, {"score": 0, "creation_date": 1419934103, "post_id": 27703152, "comment_id": 43818924, "body": "Thanks for pointing out.Is it possible to achieve this using Regular expression?"}], "score": 6, "last_activity_date": 1604950996, "last_edit_date": 1604950996, "answer_id": 27703152, "question_id": 27703039, "body": "<p>Inverting your character set will work, because in your character set you have all the valid characters:</p>\n<pre><code>var characterSet:NSCharacterSet = NSCharacterSet(charactersInString: &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;)\nif (searchTerm!.rangeOfCharacterFromSet(characterSet.invertedSet).location == NSNotFound){\n    println(&quot;No special characters&quot;)\n}\n</code></pre>\n<p>Hope this helps.. :)</p>\n"}, {"score": 3, "last_activity_date": 1448015285, "answer_id": 33824329, "question_id": 27703039, "body": "<p>@Martin R answer is great, I just wanted to update it (the second part) to Swift 2.1 version</p>\n\n<pre><code>let regex = try! NSRegularExpression(pattern: \".*[^A-Za-z0-9].*\", options: NSRegularExpressionOptions())\nif regex.firstMatchInString(searchTerm!, options: NSMatchingOptions(), range:NSMakeRange(0, searchTerm!.characters.count)) != nil {\n    print(\"could not handle special characters\")\n}\n</code></pre>\n\n<p>I used <code>try!</code> as we can be sure it create a regex, it doesn't base on any dynamic kind of a data</p>\n"}, {"score": 2, "last_activity_date": 1604951015, "last_edit_date": 1604951015, "answer_id": 37733918, "question_id": 27703039, "body": "<p>Depending on the definition of special characters, you could use this:</p>\n<pre><code>let chars =  &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;\n\nchars.canBeConvertedToEncoding(NSASCIIStringEncoding)\n</code></pre>\n"}, {"score": 5, "last_activity_date": 1516109458, "answer_id": 48282436, "question_id": 27703039, "body": "<p>Password validation With following:- (Password at least eight characters long, one special character, one uppercase, one lower case letter and one digit)</p>\n\n<pre><code>var isValidateSecialPassword : Bool {\n\n        if(self.count&gt;=8 &amp;&amp; self.count&lt;=20){\n        }else{\n            return false\n        }\n        let nonUpperCase = CharacterSet(charactersIn: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").inverted\n        let letters = self.components(separatedBy: nonUpperCase)\n        let strUpper: String = letters.joined()\n\n        let smallLetterRegEx  = \".*[a-z]+.*\"\n        let samlltest = NSPredicate(format:\"SELF MATCHES %@\", smallLetterRegEx)\n        let smallresult = samlltest.evaluate(with: self)\n\n        let numberRegEx  = \".*[0-9]+.*\"\n        let numbertest = NSPredicate(format:\"SELF MATCHES %@\", numberRegEx)\n        let numberresult = numbertest.evaluate(with: self)\n\n        let regex = try! NSRegularExpression(pattern: \".*[^A-Za-z0-9].*\", options: NSRegularExpression.Options())\n        var isSpecial :Bool = false\n        if regex.firstMatch(in: self, options: NSRegularExpression.MatchingOptions(), range:NSMakeRange(0, self.count)) != nil {\n            print(\"could not handle special characters\")\n            isSpecial = true\n        }else{\n            isSpecial = false\n        }\n        return (strUpper.count &gt;= 1) &amp;&amp; smallresult &amp;&amp; numberresult &amp;&amp; isSpecial\n    }\n</code></pre>\n"}, {"score": 10, "last_activity_date": 1527061009, "answer_id": 50482471, "question_id": 27703039, "body": "<p>This answer may help the people who are using <strong>Swift 4.1</strong></p>\n\n<pre><code>func hasSpecialCharacters() -&gt; Bool {\n\n    do {\n        let regex = try NSRegularExpression(pattern: \".*[^A-Za-z0-9].*\", options: .caseInsensitive)\n        if let _ = regex.firstMatch(in: self, options: NSRegularExpression.MatchingOptions.reportCompletion, range: NSMakeRange(0, self.count)) {\n            return true\n        }\n\n    } catch {\n        debugPrint(error.localizedDescription)\n        return false\n    }\n\n    return false\n}\n</code></pre>\n\n<p>Taken reference from @Martin R's answer.</p>\n"}, {"score": 1, "last_activity_date": 1604951043, "last_edit_date": 1604951043, "answer_id": 56275031, "question_id": 27703039, "body": "<p>Two Solutions:</p>\n<p><strong>1)</strong></p>\n<pre><code>extension String {\n    var stripped: String {\n        let okayChars = Set(&quot;abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)\n        return self.filter {okayChars.contains($0) }\n    }\n}\n</code></pre>\n<p><strong>2)</strong></p>\n<pre><code>class TrimDictionary {\n\n    static func trimmedWord(wordString: String) -&gt; String {\n        var selectedString = wordString\n    \n        let strFirst = selectedString.first\n        let strLast = selectedString.last\n    \n        let characterset = CharacterSet(charactersIn: &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)\n        if strFirst?.description.rangeOfCharacter(from: characterset.inverted) != nil {\n            selectedString = String(selectedString.dropFirst())\n        }\n        if strLast?.description.rangeOfCharacter(from: characterset.inverted) != nil {\n            selectedString = String(selectedString.dropLast())\n        }\n        return selectedString\n    }\n}\n</code></pre>\n"}, {"score": 0, "last_activity_date": 1568990064, "answer_id": 58030426, "question_id": 27703039, "body": "<p>Mahendra's answer can be stripped down a bit by using an inversion(^) within the regex clause. Additionally, you don't need A-Z and a-z when using the caseInsensitive option, as Swift covers that eventuality for you:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>extension String {\r\n\r\n  func containsSpecialCharacters(string: String) -&gt; Bool {\r\n        \r\n        do {\r\n            let regex = try NSRegularExpression(pattern: \"[^a-z0-9 ]\", options: .caseInsensitive)\r\n            if let _ = regex.firstMatch(in: string, options: [], range: NSMakeRange(0, string.count)) {\r\n                return true\r\n            } else {\r\n                return false\r\n            }\r\n        } catch {\r\n            debugPrint(error.localizedDescription)\r\n            return true\r\n        }\r\n    }</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"}, {"score": 1, "last_activity_date": 1571385197, "answer_id": 58446321, "question_id": 27703039, "body": "<p>For the purpose of filename sanitization, I prefer to detect the invalid characters, rather than provide an allowed character set. After all, many non-English speaking users need accented characters. The following function is inspired by <a href=\"https://gist.github.com/totocaster/3a1f008c780793b86a6c4d2d6ae735c4\" rel=\"nofollow noreferrer\">this gist</a>:</p>\n\n<pre><code>func checkForIllegalCharacters(string: String) -&gt; Bool {\n    let invalidCharacters = CharacterSet(charactersIn: \"\\\\/:*?\\\"&lt;&gt;|\")\n    .union(.newlines)\n    .union(.illegalCharacters)\n    .union(.controlCharacters)\n\n    if string.rangeOfCharacter(from: invalidCharacters) != nil {\n        print (\"Illegal characters detected in file name\")\n        // Raise an alert here\n        return true\n    } else {\n    return false\n}\n</code></pre>\n"}, {"score": 8, "last_activity_date": 1571855485, "answer_id": 58529048, "question_id": 27703039, "body": "<p>With <strong>Swift 5</strong> you can just do</p>\n\n<pre><code>if let hasSpecialCharacters =  \"your string\".range(of: \".*[^A-Za-z0-9].*\", options: .regularExpression) != nil {}\n</code></pre>\n"}], "is_answered": true, "answer_count": 10, "score": 37, "last_activity_date": 1604951043, "creation_date": 1419932722, "question_id": 27703039, "title": "Check if string contains special characters in Swift", "body": "<p>I have to detect whether a string contains any special characters. How can I check it? Does Swift support regular expressions?</p>\n<pre><code>var characterSet:NSCharacterSet = NSCharacterSet(charactersInString: &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;)\nif (searchTerm!.rangeOfCharacterFromSet(characterSet).location == NSNotFound){\n    println(&quot;Could not handle special characters&quot;)\n}\n</code></pre>\n<p>I tried the code above, but it matches only if I enter the first character as a special character.</p>\n"}