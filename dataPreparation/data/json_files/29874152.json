{"tags": ["c++", "regex", "algorithm", "parsing", "parameters"], "comments": [{"score": 1, "creation_date": 1430026482, "post_id": 29874152, "comment_id": 47873113, "body": "It&#39;s absolutely what regexes are for, about fifteen lines of code when you are finished."}, {"score": 0, "creation_date": 1430029948, "post_id": 29874152, "comment_id": 47873727, "body": "regex would make a much cleaner code indeed but I can&#39;t promise you it would be faster though"}, {"score": 0, "creation_date": 1430045041, "post_id": 29874152, "comment_id": 47877455, "body": "An old miss-quote:   &quot;I have a problem, part of which I can solve with a Regex&quot;.    &quot;Now you have two problems.&quot;"}], "answers": [{"comments": [{"score": 0, "creation_date": 1430033019, "post_id": 29874613, "comment_id": 47874404, "body": "Did you test that? I would have thought that <code>&#47;&#47;</code> would match two slashes. If they were backslashes (`\\`), it would be different."}, {"score": 0, "creation_date": 1430033198, "post_id": 29874613, "comment_id": 47874440, "body": "I typed this one out of memory so I guess it&#39;s wrong. I tend to confuse the syntax since it&#39;s always similar"}], "score": 0, "last_activity_date": 1430033256, "last_edit_date": 1430033256, "answer_id": 29874613, "question_id": 29874152, "body": "<p>The easiest one I've found (might not be the best but should work with your input data) is</p>\n\n<pre><code>std::string subject(\"/product/country/123456/city/7890/g.json\");\nstd::regex re(\"/(\\d+)/city/(\\d+)/\");\nstd::smatch match;\nstd::regex_search(subject, match, re);\n</code></pre>\n\n<p>It matches two values per line. The <code>/</code> matches for the slash at the beginning/end and the <code>()</code> does the capture. You will have to convert it from the string type though.</p>\n"}], "is_answered": false, "answer_count": 1, "score": 0, "last_activity_date": 1430033256, "creation_date": 1430026337, "question_id": 29874152, "title": "Would Rewriting It Using Regex Shorten/Beautify The Code?", "body": "<p>The problem is a little challenging because I want to code it using <code>std::regex</code> believing it would be easier to read and faster to write.</p>\n\n<p>But it seems that I can only code it one way (shown below).</p>\n\n<p>Somehow my mind could not see the solution using <code>std::regex</code>.</p>\n\n<p>How would you code it? </p>\n\n<p>Would using <code>std::regex_search</code> do the job?</p>\n\n<pre><code>/*\ninput: data coming in:\n/product/country/123456/city/7890/g.json\n\ninput: url parameter format:\n/product/country/&lt;id1:[0-9]+&gt;/city/&lt;id2:[0-9]+&gt;/g.json\n\noutput:\nstd::vector&lt;std::string&gt; urlParams\n\nsample output:\nurlParams[0] = \"123456\"\nurlParams[1] = \"7890\"\n*/\n\nbool ParseIt(const char *path, const char* urlRoute, std::vector&lt;std::string&gt; *urlParams)\n{\n   const DWORD BUFSZ = 2000;\n   char buf[BUFSZ];\n   DWORD dwSize = strlen(urlRoute);\n   urlParams.clear();\n\n   int j = 0;\n   int i = 0;\n   bool good = false;\n   for (i = 0; i &lt; dwSize; i++)\n   {\n       char c1 = path[j++];\n       char c2 = urlRoute[i];\n       if (c2 == '&lt;')\n       {\n           good = true;\n           while (c2 != '/')\n           { \n               i++;\n               c2 = urlRoute[i];\n           }\n           int k = 0;\n           memset(buf, 0, BUFSZ);\n           while (c1 != '/')\n           {\n               buf[k++] = c1;\n               c1 = path[j++];\n           }\n           urlParams-&gt;push_back(_strdup(buf));\n           int b = 1;\n       }\n       if (c1 != c2)\n       {\n           return false;\n       }\n       if (c2 != '&lt;')\n       {\n           if (c1 == c1)\n           {\n\n           }\n           else\n           {\n               return false;\n           }\n        }\n\n    }\n\n    if (dwSize == i &amp;&amp; good)\n    {\n        return true;\n    }\n\n    return false;\n}\n</code></pre>\n"}