{"tags": ["javascript", "django"], "answers": [{"score": 0, "last_activity_date": 1548838979, "answer_id": 54436795, "question_id": 54435029, "body": "<p>I changed my consumer.py and now it works:</p>\n\n<pre><code>class ChatConsumer(AsyncConsumer):\n    async def websocket_connect(self, event):\n        print(\"connected\", event)\n        other_user = self.scope['url_route']['kwargs']['username']\n        me = self.scope['user']\n        thread_obj = await self.get_thread(me, other_user)\n        self.get_thread_obj = thread_obj\n        chat_room = \"thread_{}\".format(thread_obj.id)\n        self.chat_room = chat_room\n        await self.channel_layer.group_add(\n            chat_room,\n            self.channel_name\n        )\n        await self.send({\n            \"type\": \"websocket.accept\"\n        })\n\n    async def websocket_receive(self, event):\n        front_text = event.get('text', None)\n        if front_text is not None:\n            loaded_dict_data = json.loads(front_text)\n            msg = loaded_dict_data.get('message')\n            user = self.scope['user']\n            username = 'default'\n            if user.is_authenticated:\n                username = user.username\n            myResponse = {\n                'message': msg,\n                'username': username\n            }\n\n            await self.create_chat_message(user, msg)\n\n            await self.channel_layer.group_send(\n                self.chat_room,\n                {\n                    \"type\": \"chat_message\",\n                    \"text\": json.dumps(myResponse)\n                }\n            )\n\n    async def chat_message(self, event):\n        await self.send({\n            \"type\": \"websocket.send\",\n            \"text\": event['text']\n        })\n\n    async def websocket_disconnect(self, event):\n        print(\"disconnected\", event)\n\n    @database_sync_to_async\n    def get_thread(self, user, other_username):\n        return Thread.objects.get_or_new(user, other_username)[0]\n\n    @database_sync_to_async\n    def create_chat_message(self, me, msg):\n        thread_obj = self.get_thread_obj\n        return ChatMessage.objects.create(thread=thread_obj, user=me, message=msg)\n</code></pre>\n"}], "is_answered": false, "answer_count": 1, "score": 0, "last_activity_date": 1548838979, "creation_date": 1548832099, "question_id": 54435029, "title": "Cant send message from back to front using django channels", "body": "<p>I can send data from front to back but there is problem in sending message from my WebSocket recieve function in consumers.py to socket.onmessage in\nthread.html. Here is both codes:</p>\n\n<pre class=\"lang-python prettyprint-override\"><code>import asyncio\nimport json\nfrom django.contrib.auth import get_user_model\nfrom channels.consumer import AsyncConsumer\nfrom channels.db import database_sync_to_async\nfrom .models import Thread, ChatMessage\n\n\nclass ChatConsumer(AsyncConsumer):\n    async def websocket_connect(self, event):\n        print(\"connected\", event)\n        await self.send({\n            \"type\": \"websocket.accept\"\n        })\n\n        other_user = self.scope['url_route']['kwargs']['username']\n        me = self.scope['user']\n        thread_obj = await self.get_thread(me, other_user)\n\n    async def websocket_receive(self, event):\n        print(\"receive\", event)\n        front_text = event.get('text', None)\n        if front_text is not None:\n            loaded_dict_data = json.loads(front_text)\n            msg = loaded_dict_data.get('message')\n            print(msg)\n            user = self.scope['user']\n            username = 'default'\n            if user.is_authenticated:\n                username = user.username\n            myResponse = {\n                'message': \"this is a instant message\",\n                'username': username\n            }\n            await self.send({\n                \"type\": \"Websocket.send\",\n                \"text\": json.dumps(myResponse),\n            })\n        # {'type': 'websocket.receive', 'text': '{\"message\":myResponse}'}\n\n    async def websocket_disconnect(self, event):\n        print(\"disconnected\", event)\n\n    @database_sync_to_async\n    def get_thread(self, user, other_username):\n        return Thread.objects.get_or_new(user, other_username)[0]\n</code></pre>\n\n<p>I have put print function inside websocket recieve and it is called but I'm not sure about self.send and I don't know how can i send it</p>\n\n<p>And here is thread.html:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>{% extends \"base.html\" %}\n{% block content %}\n&lt;p&gt;Thread for {% if user != object.first %}{{ object.first }}{% else %}{{ object.second }}{% endif %}&lt;/p&gt;\n&lt;ul id='chat-items'&gt;\n{% for chat in object.chatmessage_set.all %}\n\n&lt;li&gt;{{ chat.message }} via {{ chat.user }}&lt;/li&gt;\n\n{% endfor %}\n&lt;/ul&gt;\n\n&lt;form id='form' method='POST'&gt; {% csrf_token %}\n    &lt;input type=\"hidden\" id=\"myUsername\" value='{{ user.username }}'&gt;\n{{form.as_p }}\n&lt;input type='submit' class='btn btn-primary'/&gt;\n&lt;/form&gt;\n\n{% endblock %}\n\n{% block script %}\n\n&lt;script&gt;\n// websocket scripts\nconsole.log(window.location);\nvar loc = window.location;\nvar formData = $(\"#form\");\nvar msgInput = $(\"#id_message\");\nvar chatHolder = $(\"#chat-items\");\nvar me = $('#myUsername').val()\n\nvar wsStart = 'ws://';\nif(loc.protocol === 'https:'){\n    wsStart = 'wss://'\n}\nvar endpoint = wsStart + loc.host + loc.pathname;\nvar socket = new WebSocket(endpoint);\n\n\nsocket.onmessage = function(e){\n    console.log(\"message\",e);\n    var chatDataMsg = JSON.parse(e.data);\n    chatHolder.append(\"&lt;li&gt;\"+ chatDataMsg.message + \"via\" + chatDataMsg.username + \"&lt;/li&gt;\")\n};\n\nsocket.onopen = function(e){\n    console.log(\"open\",e);\n    formData.submit(function (event) {\n        event.preventDefault();\n        var msgText = msgInput.val();\n        chatHolder.append(\"&lt;li&gt;\"+ msgText + \" via \" + me + \"&lt;/li&gt;\")\n        var finalData = {\n            'message': msgText\n        };\n       // var formDataSerialized = formData.serialize()\n        socket.send(JSON.stringify(finalData));\n        formData[0].reset()\n    })\n};\nsocket.onerror = function(e){\n    console.log(\"error\",e)\n};\nsocket.onclose = function(e){\n    console.log(\"close\",e)\n}\n\n&lt;/script&gt;\n{% endblock %}\n</code></pre>\n\n<p> </p>\n"}