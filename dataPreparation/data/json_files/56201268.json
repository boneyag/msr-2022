{"tags": ["django", "django-queryset", "django-orm"], "answers": [{"comments": [{"score": 1, "creation_date": 1558241289, "post_id": 56201285, "comment_id": 99031646, "body": "Works thanks. And I realized that getting ids of distinct values wouldn&#39;t be of any use to me. Plus I wanted a flat list of values. So this worked for me:  <code>queryset = models.UserAddress.objects.values_list(&#39;locality&#39;, flat=True).distinct()</code> and then <code>localities = list(queryset)</code>"}], "score": 1, "last_activity_date": 1558200654, "last_edit_date": 1558200654, "answer_id": 56201285, "question_id": 56201268, "body": "<h1>Distinct <em>(id, locality)</em> tuples</h1>\n\n<p>You should add the <code>id</code> to the values, like:</p>\n\n<pre><code>localities = models.UserAddress.objects.values(<b>'id'</b>, 'locality').distinct()</code></pre>\n\n<h1>Distinct localities with id</h1>\n\n<p>If you want to return the <code>id</code> together with the <code>locality</code> such that the <code>localities</code> are distinct, we can work with a subquery, like:</p>\n\n<pre><code>from django.db.models import Subquery\n\nlocs = <b>Subquery(</b>UserAddress.objects.values('locality').distinct()<b>)</b>\n\nlocalities = models.UserAddress.objects.filter(\n    <b>locality__in=locs</b>\n).values(<b>'id'</b>, 'locality')</code></pre>\n\n<p>If you use a <em>PostgreSQL</em> database, you can do this simpler by using <a href=\"https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.distinct\" rel=\"nofollow noreferrer\"><strong><code>distinct()</code></strong></a> where you can specify the column name that should be distinct:</p>\n\n<pre><code>localities = models.UserAddress.objects.values('id', 'locality').distinct(<b>'locality'</b>)</code></pre>\n"}], "is_answered": true, "answer_count": 1, "score": 0, "last_activity_date": 1558200654, "creation_date": 1558200156, "question_id": 56201268, "title": "Django ORM: Select rows by distinct column value", "body": "<p>This may sound like a silly question but I just can't figure out how to convert this simple query into django queryset.</p>\n\n<pre><code>select distinct locality, id from shootsta_bookings.users_useraddress;\n</code></pre>\n\n<p>I've tried this: </p>\n\n<pre><code>    @list_route(methods=['GET'], url_path='locations')\n    def locations(self, request, *args, **kwargs):\n        **localities = models.UserAddress.objects.all().values('locality').distinct()**\n\n        data = self.get_serializer(localities, many=True, context={'request': request}).data\n\n        return response.Ok(data)\n</code></pre>\n\n<p>But it only returns the distinct values <code>without the ids</code>.</p>\n\n<p>Here's my serializer if that helps:</p>\n\n<pre><code>class LocationListSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = models.UserAddress\n        fields = [\n            'id',\n            'locality',\n        ]\n</code></pre>\n\n<p>I'm looking for a clean solution without having to filter the queryset with <code>in</code> clause.</p>\n"}