{"tags": ["python", "regex", "dictionary", "parsing"], "comments": [{"score": 0, "creation_date": 1579841523, "post_id": 59890489, "comment_id": 105909238, "body": "Do you want to store the extracted values back in the data frame or just in the variables(C1,C2...etc) as you mentioned."}, {"score": 0, "creation_date": 1579841956, "post_id": 59890489, "comment_id": 105909310, "body": "Store in the dataframe. I will adjust to show this. Thanks"}, {"score": 0, "creation_date": 1579842820, "post_id": 59890489, "comment_id": 105909519, "body": "Does the data have this specific pattern - <i>The names all start with a single letter C,W ... and the name itself has no single letter?</i>"}, {"score": 0, "creation_date": 1579843487, "post_id": 59890489, "comment_id": 105909681, "body": "The position will vary. (C,W,D,G,UTIL). Could be (UTIL,C, W, D, G) as one example."}], "answers": [{"comments": [{"score": 0, "creation_date": 1579843746, "post_id": 59890693, "comment_id": 105909738, "body": "Because the posiition will vary  as in UTIL will not always be third. I don&#39;t believe this is work just yet. There are multiple rows in this df I will be writing a for loop for."}, {"score": 0, "creation_date": 1579858637, "post_id": 59890693, "comment_id": 105915057, "body": "@Mike.J: I edited my code. This should work for any number of rows. Pls test and let me know in case it does not."}, {"score": 0, "creation_date": 1579876432, "post_id": 59890693, "comment_id": 105924203, "body": "Will work for names containing more than 2 words as well (eg. natasha stankvoic richardson) unless the names do not contain a single upper case letter....."}, {"score": 0, "creation_date": 1583352169, "post_id": 59890693, "comment_id": 107091010, "body": "Do you have time for a question about this?"}, {"score": 0, "creation_date": 1583369996, "post_id": 59890693, "comment_id": 107096706, "body": "Yes... The question please?"}, {"score": 0, "creation_date": 1583370271, "post_id": 59890693, "comment_id": 107096768, "body": "I am having an issue with the following string. <code>PG CJ McCollum C James Ennis I UTIL Jonas Valanciunas PF Robert Covington G James Ennis II SG RJ Barrett F James Ennis III SF Royce O&#39;Neale </code>. What I have is <code>(?&lt;![A-Z] )\\b([A-Z]+) </code>. This however uses the III as a header. Also, II and I show up as well. I want to specifically search for <code>PG, C, UTIL, PF, G, SG, F, SF</code> and take the text in between."}, {"score": 0, "creation_date": 1583371260, "post_id": 59890693, "comment_id": 107096968, "body": "and IV is an issue as well"}, {"score": 0, "creation_date": 1583463758, "post_id": 59890693, "comment_id": 107134260, "body": "@Mike.J: I would do it this way .... st = &quot;PG CJ McCollum C James Ennis I UTIL Jonas Valanciunas  PF Robert Covington G James Ennis II SG RJ Barrett F James Ennis III SF Royce O&#39;Neale&quot;; st = re.sub(&quot;[I]+&quot;,&quot;&quot;,st); print(re.findall(&quot;(?&lt;![A-Z][A-Z] )\\\\b([A-Z]+ )&quot;, st))"}], "score": 2, "last_activity_date": 1579858572, "last_edit_date": 1579858572, "answer_id": 59890693, "question_id": 59890489, "body": "<pre><code>import pandas as pd\nimport numpy as np\nimport re\ndef calc_col(col):\n    '''This function takes a string,\n    finds the upper case letters or words placed as delimeter,\n    converts it to a list,\n    adds a number to the list elements if recurring.\n    Eg. input list :['W','W','W','D','D','G','C','C','UTIL']\n    o/p list: ['W1','W2','W3','D1','D2','G','C1','C2','UTIL']\n    '''\n    col_list = re.findall(\" ?([A-Z]+) \", col)\n    col_list2 = []\n    for i in col_list:\n        cnt = col_list.count(i)\n        if cnt == 1:\n            col_list2.append(i)\n        if cnt &gt; 1:\n            if i in \" \".join(col_list2):\n                continue;\n            col_list2 += [i+str(k) for k in range(1,cnt+1)] \n    return col_list2\n\ndf = pd.DataFrame(data=np.array([['C Mark Scheifele C Pierre-Luc Dubois UTIL Zach Parise W Mats Zuccarello W Oliver Bjorkstrand W Nick Foligno D Ryan Suter D Seth Jones G Devan Dubnyk'],['UTIL Kyle Connor C Pierre-Luc Dubois C Boone Jenner W Mats Zuccarello W Oliver Bjorkstrand W Nick Foligno D Ryan Suter D Seth Jones G Devan Dubnyk']]), columns=['Lineup'])\nextr_row = df['Lineup'].replace(to_replace =\" ?[A-Z]+ \", value=\"\\n\", regex = True) #split the rows on \n\ndf_final = pd.DataFrame(columns = sorted(calc_col(df['Lineup'].iloc[0]))) #Create an empty data frame df3 with sorted columns\n\nfor i in range(len(extr_row)): #traverse all the rows in the original dataframe and append the formatted rows to df3\n    df_temp = pd.DataFrame((extr_row.values[i].split(\"\\n\")[1:])).T\n    df_temp.columns = calc_col(df['Lineup'].iloc[i])\n    df_temp= df_temp[sorted(df_temp)]\n    df_final = df_final.append(df_temp)\ndf_final.reset_index(drop = True, inplace = True)\ndf_final\n</code></pre>\n\n<p>Please see the picture below for the final data frame. This should work for any number of rows:\n<a href=\"https://i.stack.imgur.com/MHCNz.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/MHCNz.png\" alt=\"enter image description here\"></a></p>\n"}, {"comments": [{"score": 0, "creation_date": 1579846706, "post_id": 59890805, "comment_id": 105910488, "body": "Thank you. I have updated the question to add in another row to the dataframe. There will be multiple rows of strings to parse so the end result would need to loop through. I apologize for not displaying this originally."}, {"score": 0, "creation_date": 1579847272, "post_id": 59890805, "comment_id": 105910632, "body": "Updated to allow multiple strings to be passed, however you would need to merge the two returned data frames to get the result you want, I have to run out for a bit so hope it helps!"}, {"score": 0, "creation_date": 1579847890, "post_id": 59890805, "comment_id": 105910820, "body": "Eh - Updated one more time. Try the second block of code and see if it merges the <code>dataframes</code> together like you would like."}], "score": 0, "last_activity_date": 1579847988, "last_edit_date": 1579847988, "answer_id": 59890805, "question_id": 59890489, "body": "<p>This version will give you the ability to have random orders, lengths (varying counts of <code>ids</code> and more. However, it relies on the indicator that a completely capitalised word is an <code>id</code>.</p>\n\n<pre><code>import pandas as pd\n\ndef get_df(string):\n\n    result = [[key, f\"{string[i + 1]} {string[i + 2]}\"] for i, key in enumerate(string) if key.isupper()]\n\n    occurs = {}\n\n    for data in result:\n        if data[0] not in occurs:\n            occurs[data[0]] = 1\n            data[0] = f\"{data[0]}1\"\n        else:\n            occurs[data[0]] += 1\n            data[0] = f\"{data[0]}{occurs[data[0]]}\"\n\n    return pd.DataFrame(data=[[i[1] for i in result]], columns=[i[0] for i in result])\n\ndata = ['C Mark Scheifele C Pierre-Luc Dubois UTIL Zach Parise W Mats Zuccarello W Oliver Bjorkstrand W Nick Foligno D Ryan Suter \\\n         D Seth Jones G Devan Dubnyk','UTIL Kyle Connor C Pierre-Luc Dubois C Boone Jenner W Mats Zuccarello W Oliver Bjorkstrand \\\n         W Nick Foligno D Ryan Suter D Seth Jones G Devan Dubnyk']\n\n\nfor i in data:\n    print(get_df(i.split()))\n</code></pre>\n\n<p>Try this if you want to append the returned data frames together, hopefully returns the same data you're aiming for. </p>\n\n<pre><code>df = pd.DataFrame()\n\nfor i in data:\n    df = df.append(get_df(i.split()))\n    print(get_df(i.split()))\n\n\n                  C1                 C2          D1          D2            G1        UTIL1               W1                  W2            W3\n0     Mark Scheifele  Pierre-Luc Dubois  Ryan Suter  Seth Jones  Devan Dubnyk  Zach Parise  Mats Zuccarello  Oliver Bjorkstrand  Nick Foligno\n0  Pierre-Luc Dubois       Boone Jenner  Ryan Suter  Seth Jones  Devan Dubnyk  Kyle Connor  Mats Zuccarello  Oliver Bjorkstrand  Nick Foligno\n</code></pre>\n"}], "is_answered": true, "answer_count": 2, "score": 1, "last_activity_date": 1579858572, "creation_date": 1579841140, "question_id": 59890489, "title": "Python: Regex or Dictionary", "body": "<p>I have a DataFrame Column with one long string I would like to Parse. I am new to regex and have not worked with it yet. What I have below only returns the first name.. at best. I am wondering if parsing this string is easier for regex or creating a dictionary to iterate through. Here is what I have at the moment. The order is not always the same (C,W,D,G,UTIL) and I will be writing a for loop to iterate through multiple rows just like this one. </p>\n\n<pre><code>import pandas as pd\nimport numpy as np\nimport re\n\ndf = pd.DataFrame(data=np.array([['C Mark Scheifele C Pierre-Luc Dubois UTIL Zach Parise W Mats Zuccarello W Oliver Bjorkstrand W Nick Foligno D Ryan Suter D Seth Jones G Devan Dubnyk'],['UTIL Kyle Connor C Pierre-Luc Dubois C Boone Jenner W Mats Zuccarello W Oliver Bjorkstrand W Nick Foligno D Ryan Suter D Seth Jones G Devan Dubnyk']]), columns=['Lineup'])\n\ndf['C1'] = re.findall(r\" C \\w+\",str(df['Lineup']))\ndf['C2'] = re.findall(r'C \\w+',str(df['Lineup']))\ndf['W1'] = re.findall(r'W \\w+',str(df['Lineup']))\ndf['W2'] = re.findall(r'W \\w+',str(df['Lineup']))\ndf['W3'] = re.findall(r'W \\w+',str(df['Lineup']))\ndf['D1'] = re.findall(r'D \\w+',str(df['Lineup']))\ndf['D1'] = re.findall(r'D \\w+',str(df['Lineup']))\ndf['G']= re.findall(r'G \\w+',str(df['Lineup']))\ndf['UTIL'] = re.findall(r'UTIL \\w+',str(df['Lineup']))\n</code></pre>\n\n<p>I am looking for storing these values into the DF.</p>\n\n<p><code>df['C1'] = Mark Scheifele</code>\n    <code>df['C2'] = Pierre-Luc Dubois</code>\n    <code>df['W1'] = Mats Zuccarello</code>\n    <code>df['W2'] = Oliver Bjorkstrand</code>\n    <code>df['W3'] = Nick Foligno</code>\n    <code>df['D1'] = Ryan Suter</code>\n    <code>df['D2'] = Seth Jones</code>\n    <code>df['G']= Devan Dubnyk</code>\n    <code>df['UTIL'] = Zach Parise</code></p>\n\n<p>RESULT DATAFRAME\n<code>df_result = pd.DataFrame(data=np.array([['Mark Scheifele','Pierre-Luc Dubois','Mats Zuccarello','Oliver Bjorkstrand','Nick Foligno','Ryan Suter','Seth Jones','Devan Dubnyk','Zach Parise'],['Boone Jenner','Pierre-Luc Dubois','Mats Zuccarello','Oliver Bjorkstrand','Nick Foligno','Ryan Suter','Seth Jones','Devan Dubnyk','Kyle Connor']]), columns=['C1','C2','W1','W2','W3','D1','D2','G','UTIL'])</code></p>\n"}