{"tags": ["python", "django"], "comments": [{"score": 0, "creation_date": 1549017042, "post_id": 54477472, "comment_id": 95762085, "body": "Django gives AssertionError as it Cannot reorder a query once a slice has been taken. Don&#39;t know why you are not getting it."}, {"score": 0, "creation_date": 1549018254, "post_id": 54477472, "comment_id": 95762782, "body": "@IshwarJangid where have you seen a reorder ?"}, {"score": 1, "creation_date": 1549018334, "post_id": 54477472, "comment_id": 95762823, "body": "@bruno desthuilliers  calling the <code>last</code> will do reorder by <code>-pk</code> key if none has been applied before <a href=\"https://github.com/django/django/blob/75d627888bf42f8de6064a0bd665c98c0df66c55/django/db/models/query.py#L645\" rel=\"nofollow noreferrer\">github.com/django/django/blob/&hellip;</a>."}, {"score": 1, "creation_date": 1549018528, "post_id": 54477472, "comment_id": 95762936, "body": "@Take_Care_ indeed, I just saw this - so the answer to Ishwar is: because his model defines a default ordering."}, {"score": 0, "creation_date": 1549024289, "post_id": 54477472, "comment_id": 95765988, "body": "With Django 2.1.5, for models without default ordering, I get <code>Cannot reorder a query once a slice has been taken</code> for both <code>first()</code>and <code>last()</code>. For models with default ordering, <code>first()</code> works, <code>last()</code> gives an error. So I cannot replicate the behavior above with the available information. Can you show us the RSSFeed model? What&#39;s your Django version?"}, {"score": 0, "creation_date": 1549104314, "post_id": 54477472, "comment_id": 95790254, "body": "I use Django 1.1. I think its not important how the model looks like since I encounter this behaviour for every model."}], "answers": [{"comments": [{"score": 0, "creation_date": 1549020412, "post_id": 54478275, "comment_id": 95763930, "body": "Hm interesting that I am the first one who encounters this &quot;bug&quot; because last() is actually a really basic thing."}, {"score": 0, "creation_date": 1549020877, "post_id": 54478275, "comment_id": 95764138, "body": "Yeah I was a bit suprised too actually. OTHO  using both slicing and <code>last</code> together might not that common either - I obviously never did at least (else I would certainly have found this out), and I&#39;ve worked on dozens of Django projects..."}, {"score": 0, "creation_date": 1549024840, "post_id": 54478275, "comment_id": 95766316, "body": "One reason it might not be so common is that it gives an error for most people :). Specifically, <code>reverse()</code> and therefore <code>last()</code> is forbidden for sliced querysets. What Django version did you get this to work with?"}, {"score": 0, "creation_date": 1549024963, "post_id": 54478275, "comment_id": 95766393, "body": "@EndreBoth I almost often specify a default sort for my models so I don&#39;t get the &quot;sliced queryset/ordering&quot; issue."}, {"score": 0, "creation_date": 1549024997, "post_id": 54478275, "comment_id": 95766411, "body": "See my comment on the question about the default sort."}, {"score": 0, "creation_date": 1549025119, "post_id": 54478275, "comment_id": 95766482, "body": "@EndreBoth still stuck with 1.11 atm."}, {"score": 0, "creation_date": 1549040320, "post_id": 54478275, "comment_id": 95774918, "body": "Then it seems the bug has been fixed; there is probably a related ticket in Django&#39;s issue system somewhere."}], "score": 2, "last_activity_date": 1549019305, "answer_id": 54478275, "question_id": 54477472, "body": "<p>The answer is in the code actually. <code>QuerySet.last()</code> is defined as </p>\n\n<pre><code>    for obj in (self.reverse() if self.ordered else self.order_by('-pk'))[:1]:\n        return obj\n</code></pre>\n\n<p>and what <code>QuerySet.reverse()</code> basically does is to return a clone of the queryset <a href=\"https://github.com/django/django/blob/master/django/db/models/query.py#L1085\" rel=\"nofollow noreferrer\">with the direction of the <code>order by</code> clause reverted</a>, so basically instead of</p>\n\n<pre><code>SELECT (...) from yourmodel ORDER BY somefield ASC LIMIT 10\n</code></pre>\n\n<p>the SQL query becomes:</p>\n\n<pre><code>SELECT (...) from yourmodel ORDER BY somefield DESC LIMIT 10\n</code></pre>\n\n<p>so <code>first_ten_feeds.last()</code> will actually returns the same thing as <code>RSSFeed.objects.last()</code>.</p>\n\n<p>This behaviour <a href=\"https://django.readthedocs.io/en/2.1.x/ref/models/querysets.html#last\" rel=\"nofollow noreferrer\">doesn't really match the doc</a> and is quite surprising, not to say totally unexpected, and I strongly suggest you fill in a bug report on django's issue tracker - either it's the expected behaviour (for the django devs at least) and then it should be clearly documented, or it's a plain bug.</p>\n"}], "is_answered": true, "answer_count": 1, "score": 0, "last_activity_date": 1549019305, "creation_date": 1549016612, "question_id": 54477472, "title": "last() and [] operator give different results", "body": "<p>I have a model RSSFeed.\nTo get the last element in my DB, I do:</p>\n\n<pre><code>RSSFeed.objects.last()\n# Output: &lt;RSSFeed: www.sooperarticles.com&gt;\n</code></pre>\n\n<p>I slice it to get the first 10 element in the query</p>\n\n<pre><code>first_ten_feeds = RSSFeed.objects.all()[:10]\n</code></pre>\n\n<p>Using first and the bracket operator is consistent:</p>\n\n<pre><code>first_ten_feeds.first()\n# Output: &lt;RSSFeed: pressetext News&gt;\nfirst_ten_feeds[0]\n# Output: &lt;RSSFeed: pressetext News&gt;\n</code></pre>\n\n<p>But using last and the bracket operator is not consistent:</p>\n\n<pre><code>first_ten_feeds[9]\n# Output: &lt;RSSFeed: FinanzNachrichten.de: Nachrichten zu IT-Dienstleistungen&gt;\n\nfirst_ten_feeds.last()\n# Output: &lt;RSSFeed: www.sooperarticles.com&gt;\n</code></pre>\n\n<p>Why? I expect to get the same result for last() and [] above.</p>\n\n<p><code>RSSFeed.objects.last()</code> and <code>first_ten_feeds.last()</code> seem to give the same result but that does not make sense to me.</p>\n"}