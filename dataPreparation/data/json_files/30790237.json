{"tags": ["java", "json", "enums", "jackson", "deserialization"], "answers": [{"comments": [{"score": 0, "creation_date": 1434055705, "post_id": 30790760, "comment_id": 49631859, "body": "I have values which have only one name: <code>M4A(&quot;m4a&quot;)</code> Those wouldn&#39;t work with this proposed solution."}, {"score": 0, "creation_date": 1434056706, "post_id": 30790760, "comment_id": 49632350, "body": "This will also pose a problem for serializing the enum - I want only one name to be written out, not the whole list."}], "score": 4, "last_activity_date": 1434054657, "last_edit_date": 1434054657, "answer_id": 30790760, "question_id": 30790237, "body": "<p>Get rid of <strong><code>String name</code></strong> and <strong><code>List&lt;String&gt; other</code></strong> and instead have just one field - <strong><code>List&lt;String&gt; names</code></strong> and serialize the single getter with <strong><code>@JsonValue</code></strong></p>\n\n<pre><code>public enum ContainerFormat {\n//  ....\nMP4(\"mp4\", \"mpeg4\"),\nUNKNOWN(\"null\");\n\nprivate List&lt;String&gt; names;\n\nContainerFormat(List&lt;String&gt; names) {\n    this.names = new ArrayList&lt;String&gt;(names);\n}\n\n@JsonValue\npublic List&lt;String&gt; getNames()\n{\n    return this.names;\n}\n\n@JsonCreator\npublic static ContainerFormat getContainerFromValue(String value) throws JsonMappingException {\n    for (ContainerFormat format : ContainerFormat.values()) {\n        if(format.getValues().contains(value))\n            return format; \n    }\n    return UNKNOWN;\n}\n</code></pre>\n\n<p>Alternatively, if you choose to keep your existing code, you could try annotating <strong><code>otherValues()</code></strong> with <strong><code>@JsonValue</code></strong></p>\n"}, {"score": 1, "last_activity_date": 1434165474, "answer_id": 30814731, "question_id": 30790237, "body": "<p>Well, I found a workaround: one of these flags does the right thing and allows me to read that mpeg4 back in:</p>\n\n<pre><code>    mapper.configure(org.codehaus.jackson.map.SerializationConfig.Feature.WRITE_NULL_PROPERTIES, false);\n    mapper.configure(org.codehaus.jackson.map.SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING, true);\n    mapper.configure(org.codehaus.jackson.map.DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n    mapper.setPropertyNamingStrategy(org.codehaus.jackson.map.PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES);\n    mapper.setSerializationInclusion(org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion.NON_EMPTY);\n    mapper.configure(org.codehaus.jackson.map.DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n</code></pre>\n"}, {"score": 5, "last_activity_date": 1450874873, "answer_id": 34436067, "question_id": 30790237, "body": "<p>I found a good solution based on Florin's answer:</p>\n\n<p>the correct configuration with jackson 2.7.0-rc2 (and probably also before)</p>\n\n<pre><code>private ObjectMapper createObjectMapper() {\n    final ObjectMapper mapper = new ObjectMapper();\n    // enable toString method of enums to return the value to be mapped\n    mapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);\n    mapper.enable(DeserializationFeature.READ_ENUMS_USING_TO_STRING);\n    return mapper;\n}\n</code></pre>\n\n<p>In your enum you just have to override the toString() method:</p>\n\n<pre><code>public enum EXAMPLE_TYPE {\nSTART(\"start\"),\nMORE(\"more\");\n\n    // the value which is used for matching\n    // the json node value with this enum\n    private final String value;\n\n    SectionType(final String type) {\n        value = type;\n    }\n\n    @Override\n    public String toString() {\n        return value;\n    }\n}\n</code></pre>\n\n<p>You don't need any annotations or custom deserializers. </p>\n"}], "is_answered": true, "answer_count": 3, "score": 4, "last_activity_date": 1450874873, "creation_date": 1434052519, "question_id": 30790237, "title": "Jackson deserialize Enums with multiple names", "body": "<p>I have problems deserializing Enums that have multiple names for a value. Here is an example: Info is a Java class that inside has an enum with multiple names:</p>\n\n<pre><code>public class Info {\n    //...\n    private ContainerFormat format;\n}\n\n// ContainerFormat.java:\n\npublic enum ContainerFormat {\n    //  ....\n    MP4(\"mp4\", \"mpeg4\"),\n    UNKNOWN(\"null\");\n\n    private String name;\n    private List&lt;String&gt; others;\n\n    ContainerFormat(String name) {\n        this.name = name;\n    }\n\n    /** The service does not always return the same String for output formats.\n     * This 'other' string fixes the deserialization issues caused by that.\n     */\n    ContainerFormat(String name, String... others) {\n        this.name = name;\n        this.others = new ArrayList&lt;String&gt;();\n        for (String other : others) {\n            this.others.add(other);\n        }\n    }\n\n    @JsonValue\n    @Override\n    public String toString() {\n        return name;\n    }\n\n    public List&lt;String&gt; otherNames() {\n        return others;\n    }\n\n    @JsonCreator\n    public static ContainerFormat fromValue(String other) throws JsonMappingException {\n        for (ContainerFormat format : ContainerFormat.values()) {\n            if (format.toString().equalsIgnoreCase(other)) {\n                return format;\n            }\n            if (format.otherNames() != null &amp;&amp; format.otherNames().contains(other)) {\n                return format;\n            }\n        }\n        return UNKNOWN;\n    }\n}\n</code></pre>\n\n<p>The problem is when I deserialize something that contains \"mpeg4\" instead of mp4 I get this error:</p>\n\n<pre><code>com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not construct instance of com.foo.ContainerFormat from String value 'mpeg4': value not one of declared Enum instance names\n at [Source: N/A; line: -1, column: -1] (through reference chain: com.foo.Info[\"format\"])\n    at com.fasterxml.jackson.databind.exc.InvalidFormatException.from(InvalidFormatException.java:55)\n    at com.fasterxml.jackson.databind.DeserializationContext.weirdStringException(DeserializationContext.java:650)\n    at com.fasterxml.jackson.databind.deser.std.EnumDeserializer.deserialize(EnumDeserializer.java:85)\n    at com.fasterxml.jackson.databind.deser.std.EnumDeserializer.deserialize(EnumDeserializer.java:20)\n    at com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:375)\n    at com.fasterxml.jackson.databind.deser.impl.MethodProperty.deserializeAndSet(MethodProperty.java:98)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:308)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:121)\n    at com.fasterxml.jackson.databind.ObjectMapper._readValue(ObjectMapper.java:2769)\n    at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:1478)\n    at com.fasterxml.jackson.databind.ObjectMapper.treeToValue(ObjectMapper.java:1811)\n</code></pre>\n\n<p>Any pointers on how to fix this?</p>\n\n<p>TIA</p>\n"}