{"tags": ["sql", "regex", "oracle"], "comments": [{"score": 0, "creation_date": 1390219611, "post_id": 21233534, "comment_id": 31983547, "body": "<a href=\"http://stackoverflow.com/questions/5666986/how-can-i-determine-if-a-string-is-numeric-in-sql\" title=\"how can i determine if a string is numeric in sql\">stackoverflow.com/questions/5666986/&hellip;</a>"}, {"score": 0, "creation_date": 1390226029, "post_id": 21233534, "comment_id": 31987662, "body": "<code>REGEXP_COUNT(&#39;.&#39;)</code> counts ALL characters in the string. So it should be <code>REGEXP_COUNT(&#39;\\.&#39;)</code>"}], "answers": [{"score": 1, "last_activity_date": 1390303623, "last_edit_date": 1390303623, "answer_id": 21235443, "question_id": 21233534, "body": "<p>First you remove plus and minus with translate and then you wonder why their position is not considered? :-)</p>\n\n<p>This should work:</p>\n\n<pre><code>WITH dummy_data AS\n  ( SELECT '-1.0' AS txt FROM dual\n  UNION ALL\n  SELECT '+0.1' FROM dual\n  UNION ALL\n  SELECT '-.1' FROM dual\n  UNION ALL\n  SELECT '+12034.89.00' FROM dual -- invalid: duplicate decimal separator \n  UNION ALL\n  SELECT '+1,2034.89' FROM dual -- invalid: thousand separator placement\n  UNION ALL\n  SELECT 'Deva +21' FROM dual -- invalid: letters\n  UNION ALL\n  SELECT '1+1' FROM dual -- invalid: plus sign placement\n  UNION ALL\n  SELECT '1023' FROM dual\n  UNION ALL\n  SELECT '1.023,88' FROM dual -- invalid: decimal/thousand separators mixed up\n  UNION ALL\n  SELECT '1,234' FROM dual\n  UNION ALL\n  SELECT '+1,234.56' FROM dual\n  UNION ALL\n  SELECT '-123' FROM dual\n  UNION ALL\n  SELECT '+123,0000' FROM dual -- invalid: thousand separator placement\n  UNION ALL\n  SELECT '+234.' FROM dual -- invalid: decimal separator not followed by digits\n  UNION ALL\n  SELECT '12345,678' FROM dual -- invalid: missing thousand separator\n  UNION ALL\n  SELECT '+' FROM dual -- invalid: digits missing\n  UNION ALL\n  SELECT '.' FROM dual -- invalid: digits missing\n  )\nselect * from dummy_data\nwhere regexp_like(txt, '[[:digit:]]') and\n(\n  regexp_like(txt, '^[-+]{0,1}([[:digit:]]){0,3}(\\,([[:digit:]]){0,3})*(\\.[[:digit:]]+){0,1}$')\n  or \n  regexp_like(txt, '^[-+]{0,1}[[:digit:]]*(\\.[[:digit:]]+){0,1}$')\n);\n</code></pre>\n\n<p>You see, you need three regular expressions; one to guarantee that there is at least one digit in the string, one for numbers with thousand separators, and one for numbers without.</p>\n\n<p>With thousand separators: txt may start with one plus or minus sign, then there may be up to three digits. These may be followed by a thousand separator plus three digits several times. Then there may be a decimal separator with at least one following number.</p>\n\n<p>Without thousand separators: txt may start with one plus or minus sign, then there may be digits. Then there may be a decimal separator with at least one following number.</p>\n\n<p>I hope I haven't overlooked anything.</p>\n"}, {"score": 1, "last_activity_date": 1390224878, "answer_id": 21235475, "question_id": 21233534, "body": "<p>The following expression works for everything, except the commas:</p>\n\n<pre><code>'^[-+]*[0-9,]*[.]*[0-9]+$'\n</code></pre>\n\n<p>You can check for bad comma placement with additional checks like:</p>\n\n<pre><code>not regexp_like(txt, '[-+]*,$') and not regexp_like(txt, [',,'])\n</code></pre>\n"}, {"score": 0, "last_activity_date": 1390285321, "answer_id": 21250663, "question_id": 21233534, "body": "<p>I just tried to correct the mistakes of you and made the SQL simple as possible. But not neat!</p>\n\n<pre><code>WITH dummy_data AS\n  ( SELECT '-1.0' AS txt FROM dual\n  UNION ALL\n  SELECT '+.0' FROM dual\n  UNION ALL\n  SELECT '-.1' FROM dual\n  UNION ALL\n  SELECT '+1,2034.89.0' FROM dual\n  UNION ALL\n  SELECT '+1,2034.89' FROM dual\n  UNION ALL\n  SELECT 'Deva +21' FROM dual\n  UNION ALL\n  SELECT 'DeVA 234 Deva' FROM dual\n  UNION ALL\n  SELECT '1023' FROM dual\n  )\nSELECT to_number(REPLACE(txt,',')),\n  REGEXP_COUNT(txt,'.')\nFROM dummy_data\nWHERE REGEXP_LIKE (txt,'^[-+]*')\nAND NOT REGEXP_LIKE (TRANSLATE(txt,'+,-.','0000'),'[^[:digit:]]')\nAND REGEXP_COUNT(txt,',')  &lt;= 1\nAND REGEXP_COUNT(txt,'\\+') &lt;= 1\nAND REGEXP_COUNT(txt,'\\-') &lt;= 1\nAND REGEXP_COUNT(txt,'\\.') &lt;= 1;\n</code></pre>\n"}], "is_answered": true, "answer_count": 3, "score": 2, "last_activity_date": 1390303623, "creation_date": 1390219226, "question_id": 21233534, "title": "Filter the rows with number only data in a column SQL", "body": "<p>I am trying to <code>SELECT</code> rows in a table, by applying a filter condition of identifying number only columns. It is a report only query, so we least bother the performance, as we dont have the privilege to compile a PL/SQL am unable to check by <code>TO_NUMBER()</code> and return if it is numeric or not.</p>\n\n<p>I have to achieve it in SQL. Also the column is having the values like this, which have to be treated as Numbers.</p>\n\n<pre><code>-1.0\n-0.1\n-.1\n+1,2034.89\n+00000\n1023\n</code></pre>\n\n<p>After ground breaking research, I wrote this.(Hard time)</p>\n\n<pre><code>  WITH dummy_data AS\n  ( SELECT '-1.0' AS txt FROM dual\n  UNION ALL\n  SELECT '+0.1' FROM dual\n  UNION ALL\n  SELECT '-.1' FROM dual\n  UNION ALL\n  SELECT '+1,2034.89.00' FROM dual\n  UNION ALL\n  SELECT '+1,2034.89' FROM dual\n  UNION ALL\n  SELECT 'Deva +21' FROM dual\n  UNION ALL\n  SELECT '1+1' FROM dual\n  UNION ALL\n  SELECT '1023' FROM dual\n  )\nSELECT dummy_data.*,\n  REGEXP_COUNT(txt,'.')\nFROM dummy_data\nWHERE REGEXP_LIKE (TRANSLATE(TRIM(txt),'+,-.','0000'),'^[-+]*[[:digit:]]');\n</code></pre>\n\n<p>I got this.</p>\n\n<pre><code>TXT           REGEXP_COUNT(TXT,'.')\n------------- ---------------------\n-1.0                              4\n+0.1                              4\n-.1                               3\n+1,2034.89.00                    13 /* Should not be returned */\n+1,2034.89                       10\n1+1                               3 /* Should not be returned */\n1023                              4\n\n7 rows selected.\n</code></pre>\n\n<p>Now terribly confused with 2 Questions.</p>\n\n<p>1) I get <code>+1,2034.89.00</code>  too in result, I should eliminate it. (means, two decimal points) Not just decimal point, double in every other special character (-+,) should be eliminated)<br><br>\n2) To make it uglier, planned to do a <code>REGEXP_COUNT('.') &lt;= 1</code>. But it is not returning my expectation, while selecting it, I see strange values returned.</p>\n\n<p>Can someone help me to frame the <code>REGEXP</code> for the avoiding the double occurences of <code>('.','+','-')</code></p>\n"}