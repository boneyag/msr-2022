{"tags": ["php", "regex", "preg-match"], "comments": [{"score": 0, "creation_date": 1525000728, "post_id": 50085961, "comment_id": 87187558, "body": "Primarily a case of the dot <code>.</code> not matching linebreaks by default (see <code>&#47;s</code> flag). And unescaped meta chars (<code>+</code>)."}, {"score": 0, "creation_date": 1525000969, "post_id": 50085961, "comment_id": 87187628, "body": "I wonder about the context too. But might just be slavaging data from some templates, because there&#39;s no database or so."}], "answers": [{"comments": [{"score": 0, "creation_date": 1525001404, "post_id": 50086069, "comment_id": 87187741, "body": "This way you are eliminating any possible concatenated string that starts with <code>&lt;</code>."}, {"score": 0, "creation_date": 1525001434, "post_id": 50086069, "comment_id": 87187749, "body": "Works perfectly. Thank you!"}, {"score": 0, "creation_date": 1525001474, "post_id": 50086069, "comment_id": 87187760, "body": "Yep, that&#39;s the presumption. We don&#39;t have enough context from OP to know if that&#39;s useful though."}, {"score": 0, "creation_date": 1525001480, "post_id": 50086069, "comment_id": 87187763, "body": "@revo Desired string will never start with &lt; in my case."}], "score": 2, "last_activity_date": 1525001299, "answer_id": 50086069, "question_id": 50085961, "body": "<p>There's a few regex woes here:</p>\n\n<pre><code>                  \u2193              \u2193                        \u2193\npreg_match('#strs += \\'&lt;span&gt;\\';(.*?)strs += \\'&lt;/span&gt;\\';#', $html, $matches);\n</code></pre>\n\n<ul>\n<li>The <code>+</code> needs escaping</li>\n<li>The <code>.</code> requires the <code>#s</code> flag to match across linebreaks</li>\n<li>And stylistically, you should have used outermost <code>\"</code> double quotes, to avoid escaping the single quotes.</li>\n</ul>\n\n<p>Nonetheless, just extracting the text won't give you the desired list. A simpler approach is just looking for the real string appending data - given that it is somewhat consistent:</p>\n\n<pre><code> preg_match_all(\"/^\\s*strs \\+= '((?!&lt;).+)'/m\", $src, $matches);\n</code></pre>\n\n<p>Where the <code>(?!&lt;)</code> simply excludes anything like <code>&lt;span&gt;</code>. You could do more whitelisting for the expected string contents instead. And obviously, this is only workable if the text is somewhat consistent, won't honor JS syntax apart very much, etc. -- However, overall that's the simpler approach I think.</p>\n"}], "is_answered": true, "answer_count": 1, "score": -1, "last_activity_date": 1525001299, "creation_date": 1525000605, "question_id": 50085961, "title": "PHP content regex between two lines", "body": "<p>I'm trying to get content exists between two strings of <strong>JS</strong> code:</p>\n\n<pre><code>strs += '&lt;span&gt;';\n\n\nstrs += '17S32 - TAKATA FRONT AIRBAG INFLATOR - AUSTRALIA'\nstrs += '17S33 - TAKATA FRONT AIRBAG INFLATOR - AUSTRALIA'\n\nstrs += '&lt;/span&gt;';\n</code></pre>\n\n<p>I have tried the following unsuccessful approach:</p>\n\n<pre><code>preg_match('#strs += \\'&lt;span&gt;\\';(.*?)strs += \\'&lt;/span&gt;\\';#', $html, $matches);\n</code></pre>\n\n<p>My desired result is an array with following:</p>\n\n<pre><code>array(\n    0 =&gt; '17S32 - TAKATA FRONT AIRBAG INFLATOR - AUSTRALIA',\n    1 =&gt; '17S33 - TAKATA FRONT AIRBAG INFLATOR - AUSTRALIA'\n)\n</code></pre>\n"}