{"tags": ["java", "regex", "string", "optimization", "replace"], "comments": [{"score": 3, "creation_date": 1408730167, "post_id": 25452940, "comment_id": 39715406, "body": "Show us the code you tried.  Twenty pages and 5000 strings is not that many.  What is wrong with the code you are using now?"}, {"score": 0, "creation_date": 1408730231, "post_id": 25452940, "comment_id": 39715438, "body": "Use <code>ProcessBuilder</code> to have your program call <code>sed</code>???  (OK, that&#39;s the Old Linux Programmer&#39;s solution...)"}, {"score": 0, "creation_date": 1408730236, "post_id": 25452940, "comment_id": 39715440, "body": "Why do you require two passes to replace a string?"}, {"score": 0, "creation_date": 1408730258, "post_id": 25452940, "comment_id": 39715450, "body": "Maybe you should use shell <a href=\"http://www.grymoire.com/Unix/Sed.html\" rel=\"nofollow noreferrer\">grymoire.com/Unix/Sed.html</a>"}, {"score": 0, "creation_date": 1408730295, "post_id": 25452940, "comment_id": 39715475, "body": "open the file in notepad and press ctrl-h"}, {"score": 0, "creation_date": 1408730302, "post_id": 25452940, "comment_id": 39715479, "body": "If building significantly sized output incrementally, use a StringBuilder, not string concatenation (although sometimes javac helps behind the scenes). There is no need for repeated calls to String.replace (and some subtle issues associated with it). I recommend using a generated regular expression (with replaceAll or a regex-replace-walk), but even a manual word-by-word (with probe into appropriate lookup) loop will be fast."}, {"score": 1, "creation_date": 1408730304, "post_id": 25452940, "comment_id": 39715480, "body": "Practically anything will run better using C"}, {"score": 0, "creation_date": 1408730305, "post_id": 25452940, "comment_id": 39715481, "body": "I haven&#39;t written any code yet because I am looking for the most efficient algorithm first.  I am sure that either of the two approaches that I mentioned would work, but I was wondering if there is an accepted maximally optimized algorithm for this situation."}, {"score": 0, "creation_date": 1408730322, "post_id": 25452940, "comment_id": 39715488, "body": "public Matcher appendReplacement(StringBuffer sb,                                  String replacement)"}, {"score": 2, "creation_date": 1408730329, "post_id": 25452940, "comment_id": 39715492, "body": "Well heres a tip, WRITE the algorithm, then you optimize. I still don&#39;t know why you would need to passes to replace strings"}, {"score": 1, "creation_date": 1408730489, "post_id": 25452940, "comment_id": 39715571, "body": "@AlexBoulton: what redFIVE said.  Write some code, making obvious optimizations as they occur to you.  Ie, a <code>StringBuilder</code> is probably best here.  Then measure the results.  If it&#39;s fast enough, you&#39;re done.  If not, come back here as ask for a better method than the code you have.  Be prepared to show us enough of the code so that we understand what you did."}, {"score": 0, "creation_date": 1408730497, "post_id": 25452940, "comment_id": 39715574, "body": "The two bullet points don&#39;t mean two full iterations - those are just two separate approaches."}, {"score": 0, "creation_date": 1408730587, "post_id": 25452940, "comment_id": 39715617, "body": "Seriously, I think I&#39;d try joining all the search strings together with <code>|</code> to make a regex, then using just one <code>replaceAll</code>.  This could be faster or much, much slower depending on how regexes are implemented, but it might be worth a try."}, {"score": 0, "creation_date": 1408731488, "post_id": 25452940, "comment_id": 39716071, "body": "This is going to run practically instantaneously however you do it, as long as your code isn&#39;t grossly inefficient. Buffered input and output is the main concern."}, {"score": 0, "creation_date": 1408759108, "post_id": 25452940, "comment_id": 39724839, "body": "Are you replacing each of 5000 strings with one string - the same string - every time? Or does each of 5000 strings have its own replacement - ie 5000 replacements for 5000 strings? This is not clear to me from the question."}], "answers": [{"score": 0, "last_activity_date": 1408730684, "answer_id": 25453076, "question_id": 25452940, "body": "<p>I would use the commons-lang library, which I think has exactly what you are looking for. Basically you create one array with all the strings you want to substitute and another array with the substitutions. See <a href=\"http://commons.apache.org/proper/commons-lang/javadocs/api-release/index.html\" rel=\"nofollow\">http://commons.apache.org/proper/commons-lang/javadocs/api-release/index.html</a> for details on the StringUtils#replaceEach method.</p>\n"}, {"comments": [{"score": 0, "creation_date": 1408731575, "post_id": 25453147, "comment_id": 39716113, "body": "And herein lies the problem of not actually writing any code before asking a question on SO"}, {"score": 0, "creation_date": 1408732229, "post_id": 25453147, "comment_id": 39716428, "body": "Just put 5000 strings in <code>hashmap</code> and you&#39;re golden"}, {"score": 0, "creation_date": 1408732460, "post_id": 25453147, "comment_id": 39716548, "body": "@redFIVE Im just saying he should consider size and memory availability. Furthermore, some data structures have different complexity which might make them more or less efficient with more or less data."}, {"score": 0, "creation_date": 1408732579, "post_id": 25453147, "comment_id": 39716614, "body": "I think you will be hard pressed to find a more efficient method of finding a string out of 5000 possible unsorted entries than sticking it all in a hashmap"}, {"score": 0, "creation_date": 1408732794, "post_id": 25453147, "comment_id": 39716711, "body": "I think the question remains, what are you going to do with it? I agree that a (hash)map is a plausible solution. But what if he only replaces 2 strings? Then you will store 5000+ strings? Then find the replacements?"}, {"score": 1, "creation_date": 1408732803, "post_id": 25453147, "comment_id": 39716715, "body": "@redFIVE only if the <i>entire</i> input string is supposed to match one of the 5000 possibilities.  If he&#39;s looking for cases where substrings of the input string match one of the possible search strings (which is how I read the question), a hashmap is not useful."}], "score": 2, "last_activity_date": 1408733222, "last_edit_date": 1495541030, "answer_id": 25453147, "question_id": 25452940, "body": "<p>You want to replace some string in 5000 strings and you want to make it optimal ... Now my question to you is: How will you know if you have to replace a string if you dont read the string? It's not possible, you have to read everything. And the shortest way to do that is to go line by line and replace immediatly. And somebody can correct me if i'm wrong, but reading a file is one of the most basic operations there is so using a library for that besides what is available by default in the programming language seems total overkill to me. Furthermore, every language has basic io and if it doesn't then don't use it. </p>\n\n<p>To store strings, it all depends what you want to do with them. Different data structures have different purposes and some are better suited in some situations then others. If you just need to store them then a simple array is fine. However, if you need more advanced functions then you need to consider your options. But again it's all up to what you want to do with them later.\nAnd there is the memory issue, you need to calculate how much memory your 5000+ strings will take, because you might run out of memory. Then you need to think if it's worth it to use all that memory. <a href=\"https://stackoverflow.com/questions/4385623/bytes-of-a-string-in-java\">check this link</a></p>\n\n<p>Finally your question about C, ofcourse it will be more efficient. Java runs in a virtual machine that adds considerable overhead. So basically your Java  program runs in another Java program and if you know that there is a cost for every single operation then you understand that C will be more efficient then Java in terms of performance.</p>\n"}], "is_answered": true, "answer_count": 2, "score": -1, "last_activity_date": 1408733222, "creation_date": 1408730088, "question_id": 25452940, "title": "Most efficient way to replace many (5000+) strings in a .txt file", "body": "<p>Using a general-purpose programming language like Java, what is the most efficient way to search through a ~20 page document to replace a set of 5000+ strings with some predetermined replacement string?  The program should not replace any strings that have already been replaced.  What data structure would be optimal to store the 5000+ strings and each of their replacements - two arrays, a dictionary, or something else?</p>\n\n<p>Here are some of the options that I have considered so far:</p>\n\n<ul>\n<li><p>Iterate through the entire .txt document once time per string using string.replace.  The problem is that the algorithm must iterate through the entire .txt document an extra time for each string stored.</p></li>\n<li><p>Iterate through the .txt once while replacing string as necessary while creating a new string by appending replacements.  This seems more efficient, but each step would still require checking the entire set of 5000+ strings for any strings to replace.</p></li>\n</ul>\n\n<p>Is there a more optimized means of solving this problem, or is one of the above attempts already optimal?</p>\n\n<p>Also, would it be possible to run this algorithm more efficiently in a lower-level language like C?</p>\n"}