{"tags": ["java", "json", "jackson"], "comments": [{"post_id": 26716020, "comment_id": 42022632, "body": "Well, you can mock an <code>ObjectMapper</code> and have it throw that exception since <code>ObjectMapper</code> is not final"}, {"post_id": 26716020, "comment_id": 42024937, "body": "Wouldn&#39;t that be mocking the test itself, I would like to reproduce a scenario that can in fact happen in the context of the running application. Maybe one does not exists? If so, Why the exception? Thanks for the answer."}, {"post_id": 26716020, "comment_id": 42025377, "body": "Well, I thought you wanted to test the behaviour of your code in the event that this exception was raised, which is why I suggested this"}, {"post_id": 26716020, "comment_id": 42027167, "body": "I guess it makes sense, and if no other suggestions come up I might as well do that. I just figured there should be a way to produce that exception with some sort of random object that would not parse correctly to JSON. Damn Jackson and it&#39;s intelligent parsing."}, {"post_id": 26716020, "comment_id": 42120984, "body": "You could try giving it some XML... :-)"}], "answers": [{"answer_id": 32054934, "question_id": 26716020, "body": "<p>I wanted to do the same thing, and eventually accomplished it by using the Mockito \"spy\" function, which wraps a real object with a mock object. All calls to the mock object get forwarded to the real object, except those you are trying to mock. For example:</p>\n\n<pre><code>ObjectMapper om = Mockito.spy(new ObjectMapper());\nMockito.when( om.writeValueAsString(ErrorObject.class)).thenThrow(new JsonProcessingException(\"\") {});\n</code></pre>\n\n<p>All usages of <code>om</code> will be handled by the underlying ObjectMapper instance until an instance of <code>ErrorObject</code> gets passed in, at which point the <code>JsonProcessingException</code> will be thrown.</p>\n\n<p>The new<code>JsonProcessingException</code> is created as an anonymous class, as it is a protected class and only a sub-class can be instantiated.</p>\n"}, {"answer_id": 47381903, "question_id": 26716020, "body": "\n\n<p>You could use something like this:</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>private static class ClassThatJacksonCannotSerialize {\n    private final ClassThatJacksonCannotSerialize self = this;\n\n    @Override\n    public String toString() {\n        return self.getClass().getName();\n   }\n}\n</code></pre>\n\n<p>Which results in a <code>JsonProcessingException</code> with message <code>Direct self-reference leading to cycle (through reference chain: ClassThatJacksonCannotSerialize[\"self\"])</code></p>\n"}, {"answer_id": 47781555, "question_id": 26716020, "body": "<p>Building off of Liam's answer, mocking the <code>toString()</code> method with a cycle also causes Jackson to break.</p>\n\n<pre><code>@Test\npublic void forceJsonParseException() {\n    try {\n        Object mockItem = mock(Object.class);\n        when(mockItem.toString()).thenReturn(mockItem.getClass().getName());\n        new ObjectMapper().writeValueAsString(mockItem);\n        fail(\"did not throw JsonProcessingException\");\n    } catch (JsonProcessingException e) {\n        //pass\n    }\n}\n</code></pre>\n\n<p>EDIT: It's way easier than that. A Mockito mock will always throw it. o.o;;</p>\n"}, {"answer_id": 48956071, "question_id": 26716020, "body": "<p>For me, if a class has no <code>public</code> fields/methods, <code>writeValueAsString</code> will throw a <code>JsonMappingException</code> (<code>no serializer found for class...</code>)</p>\n<pre class=\"lang-java prettyprint-override\"><code>private static class ClassThatJacksonCannotSerialize {}\n\nprivate void forceProcessingException() {\n    ObjectMapper mapper = new ObjectMapper();\n    try {\n        return mapper.writeValueAsString(value);\n    } \n    catch (JsonProcessingException e) {\n        throw new RuntimeException(e);\n    }\n}\n</code></pre>\n"}, {"answer_id": 52835012, "question_id": 26716020, "body": "<p>following on @Mike.Mathieson answer</p>\n\n<pre><code>import com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.junit.Test;\n\npublic class JacksonTest {\n\n    @Test(expected = JsonProcessingException.class)\n    // actually throws an InvalidDefinitionException (which extends JsonProcessingException)\n    public void encodeThrowsException() throws JsonProcessingException {\n        new ObjectMapper().writeValueAsString(new Object());\n    }\n}\n</code></pre>\n\n<p><a href=\"https://fasterxml.github.io/jackson-databind/javadoc/2.9/com/fasterxml/jackson/databind/exc/InvalidDefinitionException.html\" rel=\"noreferrer\">https://fasterxml.github.io/jackson-databind/javadoc/2.9/com/fasterxml/jackson/databind/exc/InvalidDefinitionException.html</a></p>\n\n<p>note that this test won't work if the ObjectMapper have been configured to disable <code>SerializationFeature.FAIL_ON_EMPTY_BEANS</code>, e.g.</p>\n\n<pre><code>new ObjectMapper()\n    .configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false)\n    .writeValueAsString(new Object());\n</code></pre>\n"}, {"answer_id": 53707778, "question_id": 26716020, "body": "<p>Trying to mock using <code>mock(ObjectMapper.class)</code> will invariably result in <em>Checked exception is invalid for this method!</em> as it is not possible to throw checked exception (<code>JsonProcessingException</code> extends <code>IOException</code>). Creating a self referencing value object like other answers suggested could be too convoluted for many cases and looks like a hack.</p>\n\n<p>The easiest way I found is to extend <code>ObjectMapper</code> and then use that in your test method. You should pass the subclass to SUT</p>\n\n<pre><code>@Test\npublic void buildJsonSwallowsJsonProcessingException() {\n\n    class MyObjectMapper extends ObjectMapper {\n        @Override\n        public String writeValueAsString(Object value)\n                throws com.fasterxml.jackson.core.JsonProcessingException {\n            throw new com.fasterxml.jackson.core.JsonProcessingException(\"Forced error\") {};\n        }\n    }\n\n    ObjectMapper objectMapper = new MyObjectMapper();\n\n    SUTBean sutbean = new SUTBean(objectMapper);\n\n    sutbean.testMethod();\n\n    assertTrue(expected, actual);\n}\n</code></pre>\n"}, {"answer_id": 57877463, "question_id": 26716020, "body": "<p>just in case this may help someone, when i was unit testing for a JsonProcessingException i kept getting this error:</p>\n\n<pre><code>JsonProcessingException has protected access in com.fasterxml.jackson...\n</code></pre>\n\n<p>this was my code</p>\n\n<pre><code>// error is on the below line\nJsonProcessingException e = new JsonProcessingException(\"borked\");\n\ndoThrow(e).when(classMock).methodToMock(any(), any());\n</code></pre>\n\n<p><strong>i found out i just needed to add \"{}\" as such</strong></p>\n\n<pre><code>JsonProcessingException e = new JsonProcessingException(\"borked\") {};\n</code></pre>\n"}, {"answer_id": 62141812, "question_id": 26716020, "body": "<p>I found this in Jackson Github issue; but it solved my problem and I am able to throw the JsonProcessingException.</p>\n\n<pre><code> @Test\npublic void forceJsonParseException() {\ntry {\n    Object mockItem = mock(Object.class);\n    when(mockItem.toString()).thenReturn(mockItem.getClass().getName());\n    new ObjectMapper().writeValueAsString(mockItem);\n    fail(\"did not throw JsonProcessingException\");\n} catch (JsonProcessingException e) {\n    //pass\n}\n}\n</code></pre>\n\n<p>Now how I used this in my code</p>\n\n<p>Need to test this method</p>\n\n<pre><code>public String geResponse(MyObject myObject) {\n\ntry {\n  return objectMapper.writeValueAsString(myObject);\n} catch (JsonProcessingException e) {\n  log.error(\"Service response JsonParsing error {} \", e.getMessage());\n  return \"Validation Service response JsonParsing error {} \"+ e.getMessage();\n }\n}\n</code></pre>\n\n<p>This how I test the JsonProcessingException</p>\n\n<pre><code>@SneakyThrows\n@Test\npublic void testGetValidationResponseNegative() {\n    MyObject mockItem = mock(MyObject.class);\n    when(mockItem.toString()).thenReturn(mockItem.getClass().getName());\n    String vr = geResponse(mockItem);\n    assertTrue(!vr.isEmpty());\n}\n</code></pre>\n\n<p>I hope this helps!!!</p>\n"}, {"answer_id": 67056036, "question_id": 26716020, "body": "<p>Throw exception in getter to simulate JsonProcessingException.</p>\n<pre><code>public static class TestData {\n    public String getEx() throws JsonProcessingException { throw new JsonParseException(null, &quot;test&quot;); }\n}\n\nObjectMapper().writeValueAsString(new TestData());\n</code></pre>\n"}, {"answer_id": 68033438, "question_id": 26716020, "body": "<p>i was land on this question because i had the same target of the questioner:</p>\n<blockquote>\n<p>Might be a strange question but indeed I would like to achieve a a bit\nmore coverage on my tests</p>\n</blockquote>\n<p>IMHO Mockito solution it's more elegant and not introduce misunderstanding but I challenged a colleague to find another solution and he did. This is the solution:</p>\n<pre><code>@Test\n@DisplayName(&quot;Object To Json KO&quot;)\nvoid objectToJsonKOTest() {\n    KafkaMessageDTO o = new KafkaMessageDTO() {\n        @Override\n        public String getAuthCode() {\n            int a = 2/0;\n            return super.getAuthCode();\n        }\n    };\n\n    String s = mapper.writeValueAsString(o);\n    Assertions.assertTrue(s.isEmpty());\n}\n</code></pre>\n<p>This is trash, high level trash :) , but it works and I wanted to share it with you as an alternative to mock</p>\n<p>ByeBye</p>\n"}], "is_answered": true, "answer_count": 10, "last_activity_date": 1624011608, "question_id": 26716020, "title": "How to get a JsonProcessingException using Jackson", "body": "<p>Might be a strange question but indeed I would like to achieve a a bit more coverage on my tests and although I coded against a <code>JsonProcessingException</code> I can't create a payload that generates this exception, maybe because Jackson is quite smart and converts everything to a string, and even for bad strings it goes around the JSON specs. My problem is that Jackson is quite good :)</p>\n\n<p>I basically want a payload that when I run this, it break with <code>JsonProcessingException</code>:</p>\n\n<pre><code>String jsonPayload = objectMapper.writeValueAsString(payload);\n</code></pre>\n\n<p>I've tried some like:</p>\n\n<pre><code>HashMap&lt;String, String&gt; invalidJSONPayload= new HashMap&lt;&gt;();\n\ninvalidJSONPayload.put(\"021\",021);\ninvalidJSONPayload.put(\"---\",021);\ninvalidJSONPayload.put(\"~\",021);\n</code></pre>\n\n<p>I'm not fussed with the type, so feel free to suggest another one. An empty object for example, throws <code>JsonMappingException</code> and I already catch that one as well.</p>\n"}