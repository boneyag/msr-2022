{"tags": ["c#", "json", "caching", "hash", "unity3d"], "comments": [{"score": 0, "creation_date": 1433303996, "post_id": 30610545, "comment_id": 49288157, "body": "<a href=\"http://stackoverflow.com/questions/1993903/how-do-i-do-a-sha1-file-checksum-in-c\" title=\"how do i do a sha1 file checksum in c\">stackoverflow.com/questions/1993903/&hellip;</a>"}], "answers": [{"comments": [{"score": 0, "creation_date": 1433305046, "post_id": 30610586, "comment_id": 49288410, "body": "Yes MD5 is the best thing I found so far. The only issue I have with it is implementing it on the server side so that a new hash is generated everytime a change is made to the JSON on the server.  The best solution for me is an algorithm simple enough (and that doesn&#39;t require any libraries) to implement on both server and clients"}], "score": 1, "last_activity_date": 1433305990, "last_edit_date": 1433305990, "answer_id": 30610586, "question_id": 30610545, "body": "<p>If your looking for a simple hash why not just use an MD5 hash?  <a href=\"https://msdn.microsoft.com/en-us/library/system.security.cryptography.md5%28v=vs.110%29.aspx\" rel=\"nofollow\">https://msdn.microsoft.com/en-us/library/system.security.cryptography.md5%28v=vs.110%29.aspx</a>  basic hash that is easy to implement and use.</p>\n\n<p>If you are looking to do an MD5 hash on the client using JS you might want to look at <a href=\"https://github.com/blueimp/JavaScript-MD5\" rel=\"nofollow\">https://github.com/blueimp/JavaScript-MD5</a>  (Non-tested by me, but I have heard good things :)</p>\n"}, {"comments": [{"score": 0, "creation_date": 1433304855, "post_id": 30610653, "comment_id": 49288354, "body": "I thought about this but the problem is that user can still tweak the cached values without modifying the time stamp. Since the time stamp is still the same as on the server, the JSON won&#39;t be pulled again"}, {"score": 0, "creation_date": 1433351048, "post_id": 30610653, "comment_id": 49318593, "body": "can you please explain what do you mean by &#39;tweak the cached values&#39;? i think if anybody modifies the file, the hash or timestamp should be regenerated/updated."}], "score": 0, "last_activity_date": 1433304376, "answer_id": 30610653, "question_id": 30610545, "body": "<ol>\n<li>As Brad mentioned, any inbuilt Hashing technique in .NET should do the job for you. </li>\n<li>The other option is to use a UTC based timestamp. (LastModified) The server could send down this value, and if the client has the same value, then it is good to use. And whoever updates the file, can update the timestamp.</li>\n</ol>\n"}], "is_answered": true, "answer_count": 2, "score": 0, "last_activity_date": 1433318111, "creation_date": 1433303582, "question_id": 30610545, "title": "Checking JSON file integrity", "body": "<ul>\n<li>I'm working on a server based game and I'm sending my game data via a JSON from the server to the clients.</li>\n<li>To minimize bandwidth use, I cache the game data JSON on the client machine so that they do not need to download the JSON from the server everytime.</li>\n<li>I need to know if the JSON cached on the client is the same as the one on the server (it can become different either when we make changes on the server or if the user accessed and tweaked the cache on the client side).</li>\n</ul>\n\n<p>So basically I need some kind of hashing technique to get a key unique to a JSON string that I can check to see if the JSON cached on the client is the same as the one stored on the server. The server will send that hash first to the client and only if it differs from the one generated from the client cache, then the client will request the whole JSON from the server again.</p>\n\n<ul>\n<li>I do not care about data loss as the hash will never be converted back to string again.</li>\n<li>I do not care about Hash difference due to different key orders in the JSON as I make sure they are always in the right order when I get the JSON from the server.</li>\n<li>The hash shouldn't be environment specific. The same algorithm should generate the same hash regardless of environment, 32 or 64 bit and endianness.</li>\n</ul>\n"}