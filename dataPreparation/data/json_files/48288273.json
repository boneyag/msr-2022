{"tags": ["json", "scala", "playframework"], "comments": [{"score": 0, "creation_date": 1516149744, "post_id": 48288273, "comment_id": 83569133, "body": "Recent Play JSON releases support <i>sealed</i> trait (or trait with <code>apply</code>/<code>unapply</code> in companion)"}], "answers": [{"score": 1, "last_activity_date": 1516230775, "answer_id": 48311499, "question_id": 48288273, "body": "<p>Instead of building a parser at the <code>DataSource</code> level, I defined parsers at the <code>SourceConfig</code> and <code>FormatConfig</code> levels, similar to what is shown below.</p>\n\n<pre><code>sealed trait SourceConfig{val sourceType: String}\nobject SourceConfig{\n  implicit val fmt = new Format[SourceConfig] {\n    def reads(json: JsValue): JsResult[SourceConfig] = {\n      def from(sourceType: String, data: JsObject): JsResult[SourceConfig] = sourceType match {\n        case \"RDBMS\"     =&gt; Json.fromJson[RDBMSConfig](data)(RDBMSConfig.fmt)\n        case \"directory\" =&gt; Json.fromJson[DirectoryConfig](data)(DirectoryConfig.fmt)\n        case _           =&gt; JsError(s\"Unknown source type: '$sourceType'\")\n      }\n\n      for {\n        sourceType &lt;- (json \\ \"sourceType\").validate[String]\n        data       &lt;- json.validate[JsObject]\n        result     &lt;- from(sourceType, data)\n      } yield result\n    }\n\n    def writes(source: SourceConfig): JsValue =\n      source match {\n        case b: RDBMSConfig     =&gt; Json.toJson(b)(RDBMSConfig.fmt)\n        case b: DirectoryConfig =&gt; Json.toJson(b)(DirectoryConfig.fmt)\n      }\n  }\n}\n</code></pre>\n\n<p>Then, <code>DataSource</code> could be simply defined as:</p>\n\n<pre><code>object DataSource { implicit val fmt = Json.format[DataSource] }\n</code></pre>\n"}, {"score": 0, "last_activity_date": 1516287582, "answer_id": 48324235, "question_id": 48288273, "body": "<p>Another option is to use <code>play-json-derived-codecs</code> library:  </p>\n\n<pre><code>libraryDependencies += \"org.julienrf\" %% \"play-json-derived-codecs\" % \"4.0.0\"\n\nimport julienrf.json.derived.flat\n\nimplicit val format1: OFormat[RDBMSConfig] = Json.format[RDBMSConfig]\nimplicit val format2: OFormat[DirectoryConfig] = Json.format[DirectoryConfig]\nimplicit val format3: OFormat[SourceTypeConfig] = flat.oformat((__ \\ \"sourceType\").format[String])\n</code></pre>\n"}], "is_answered": true, "answer_count": 2, "score": 1, "last_activity_date": 1516287582, "creation_date": 1516129899, "question_id": 48288273, "title": "Building a Json Format for a Case Class with Abstract Members", "body": "<p>I am using the Play Framework and trying to build JSON validator for a class with abstract members. Shown below, the DataSource class is the base class which I am trying to validate the format against.</p>\n\n<pre><code>// SourceTypeConfig Trait.\n\ntrait SourceTypeConfig\n\n  final case class RDBMSConfig(...) extends SourceTypeConfig\n  object RDBMSConfig { implicit val fmt = Json.format[RDBMSConfig] }\n\n  final case class DirectoryConfig(\n      path: String,\n      pathType: String // Local, gcloud, azure, aws, etc.\n  ) extends SourceTypeConfig\n  object DirectoryConfig { implicit val fmt = Json.format[DirectoryConfig] }\n\n// FormatConfig trait.\n\ntrait FormatConfig\n\n  final case class SQLConfig(...) extends FormatConfig\n  object SQLConfig { implicit val fmt = Json.format[SQLConfig]}\n\n  final case class CSVConfig(\n      header: String,\n      inferSchema: String,\n      delimiter: String\n  ) extends FormatConfig\n  object CSVConfig { implicit val fmt = Json.format[CSVConfig]}\n\n\n// DataSource base class.\ncase class DataSource(\n      name: String,\n      sourceType: String,\n      sourceTypeConfig: SourceTypeConfig,\n      format: String,\n      formatConfig: FormatConfig\n  )\n</code></pre>\n\n<p>What I am hoping to accomplish:</p>\n\n<pre><code>val input: JsValue = Json.parse(\n      \"\"\"\n        {\n        \"name\" : \"test1\",\n        \"sourceType\" : \"directory\",\n        \"sourceTypeConfig\" : {\"path\" : \"gs://test/path\", \"pathType\" \"google\"},\n        \"format\" : \"csv\",\n        \"formatConfig\" : {\"header\" : \"yes\", \"inferSchema\" : \"yes\",  \"delimiter\" :  \"|\"}\n        }\n      \"\"\"\n    )\n\n    val inputResult = input.validate[DataSource]\n</code></pre>\n\n<p>What I am struggling with is building the DataSource object and defining its reads/writes/format. I would like it to contain a match based on the <code>sourceType</code> and <code>format</code> values that direct it to point towards the associated <code>sourceTypeConfig</code> and <code>formatConfig</code>'s formats so it can parse out the JSON.</p>\n"}