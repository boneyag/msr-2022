{"tags": ["python", "django", "filter", "manytomanyfield"], "comments": [{"score": 0, "creation_date": 1515720025, "post_id": 48218081, "comment_id": 83418455, "body": "Do you want from people, or to people, or all people?"}, {"score": 0, "creation_date": 1515727566, "post_id": 48218081, "comment_id": 83420026, "body": "A QuerySet of all People that follow a given person."}], "answers": [{"comments": [{"score": 0, "creation_date": 1515774645, "post_id": 48218284, "comment_id": 83442773, "body": "For your first two code blocks, I&#39;m told: &#39;AttributeError: &#39;ManyRelatedManager&#39; object has no attribute &#39;objects&#39;. In the end, I used the &#39;related_name&quot; to work backward."}], "score": 0, "last_activity_date": 1515728938, "last_edit_date": 1515728938, "answer_id": 48218284, "question_id": 48218081, "body": "<p>Take a look at <a href=\"https://docs.djangoproject.com/en/2.0/topics/db/queries/#lookups-that-span-relationships\" rel=\"nofollow noreferrer\">this</a> document.  Otherwise here are some other methods...</p>\n\n<p><code>self.relationships.from_people.objects.all()</code> would return all objects with of with the related name <code>from_people</code>.</p>\n\n<p>I would, however, slightly change some code such that the use would be <code>self.relationships.from_people.objects.filter(status='Following')</code>  </p>\n\n<p>Another way to do it (though not the most efficient) is to pass in the person model, and pass in the relationships model using the person.pk as a filter.</p>\n\n<pre><code>def get_following(self, pk):\n    person = Person.objects.get(pk=pk)\n    relationships = Relationship.objects.filter(to_person=person.id)\n    return relationships\n</code></pre>\n"}, {"comments": [{"score": 0, "creation_date": 1515721993, "post_id": 48218427, "comment_id": 83418895, "body": "If you do not want the name, remove <code>name</code> and you will get something like <code>&lt;QuerySet [&lt;Person: A&gt;, &lt;Person: B&gt;, ...]&gt;</code>"}, {"score": 0, "creation_date": 1515774867, "post_id": 48218427, "comment_id": 83442914, "body": "I&#39;m okay remaining with a QuerySet.  This is just a toy example, so there will be lots of relationships.  Have a look at the answer I added that uses the &#39;related_name&#39; to work backward."}], "score": 0, "last_activity_date": 1515722141, "last_edit_date": 1515722141, "answer_id": 48218427, "question_id": 48218081, "body": "<p>You got a QuerySet like this: <code>&lt;QuerySet [&lt;Relationship: B is Following C&gt;]&gt;</code>. Think that one day (I guess that it is the propose of that) 'person' has a lot of followers and it probably might return so many followers, like this: <code>&lt;QuerySet [&lt;Relationship: B is Following C&gt;, &lt;Relationship: A is Following C&gt;]&gt;</code>.\nSo, I would use values_list() [1]:</p>\n\n<pre><code>Relationship.objects.filter(to_person=p3, status='Following').values_list('from_person__name', flat=True)\n</code></pre>\n\n<p>Returns: <code>&lt;QuerySet [A, B, ...]&gt;</code></p>\n\n<p>If you only pass in a single field, you can also pass in the flat parameter. If True, this will mean the returned results are single values, rather than one-tuples.</p>\n\n<p>or create a method:</p>\n\n<pre><code>def get_followers(self):\n    follower_of_person = []\n    for value in relation_of_person:\n        follower_of_p3.append(value.from_person.name)\n    return follower_of_person\n</code></pre>\n\n<p>Returns: <code>[A, B, ...]</code></p>\n\n<p>values_list still is better, because you are working directly on the database.</p>\n\n<p>[1] <a href=\"https://docs.djangoproject.com/en/2.0/ref/models/querysets/#values-list\" rel=\"nofollow noreferrer\">https://docs.djangoproject.com/en/2.0/ref/models/querysets/#values-list</a>\n(Here have a good example of ManyToMany).</p>\n"}, {"score": 0, "last_activity_date": 1515955280, "answer_id": 48252905, "question_id": 48218081, "body": "<p>Here's the ANSWER I chose:</p>\n\n<pre><code>def get_followers(self):\n  return self.related_to.filter(from_people__status='Following')\n</code></pre>\n"}, {"score": 1, "last_activity_date": 1547216709, "last_edit_date": 1547216709, "answer_id": 54147741, "question_id": 48218081, "body": "<p>Just in case somebody else needs another way of implementing \"Followers\" exactly like you described, but with a different modelling scheme:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code># project/account/models.py\nfrom django.db import models\nfrom django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin\nfrom model_utils import Choices\n\nclass User(AbstractBaseUser, PermissionsMixin):\n    class Meta:\n        # ...\n\n    username = models.CharField(...)\n    email = models.EmailField(...)\n    # ...\n\n    ### Custom app-specific relationships (database scheme) ###\n\n    # symmetrical=False is needed for this reason: https://stackoverflow.com/a/42040848/3433137\n    following = models.ManyToManyField('self', related_name='followers', blank=True, symmetrical=False)\n</code></pre>\n\n<pre class=\"lang-py prettyprint-override\"><code># project/account/forms.py\nfrom django import forms\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.admin.widgets import FilteredSelectMultiple\nfrom .models import User\n\nclass UserChangeForm(forms.ModelForm):\n    # ...\n\n    # new:\n    following = forms.ModelMultipleChoiceField(\n        queryset=User.objects.all(),\n        required=False,\n        widget=FilteredSelectMultiple(\n            verbose_name='Following',\n            is_stacked=False\n        )\n    )\n    # new:\n    followers = forms.ModelMultipleChoiceField(\n        queryset=User.objects.all(),\n        required=False,\n        widget=FilteredSelectMultiple(\n            verbose_name='Followers',\n            is_stacked=False\n        )\n    )\n\n    class Meta:\n        model = get_user_model()\n        # add 'following' and 'followers' to the fields:\n        fields = ('email', 'password', ..., 'following', 'followers')\n\n    # also needed to initialize properly:\n    def __init__(self, *args, **kwargs):\n        super(UserChangeForm, self).__init__(*args, **kwargs)\n\n        # Filter out the self user in the lists and initialize followers list:\n        if self.instance and self.instance.pk:\n            self.fields['following'] = forms.ModelMultipleChoiceField(\n                queryset=User.objects.all().exclude(pk=self.instance.pk),\n                required=False,\n                widget=FilteredSelectMultiple(\n                    verbose_name='Following',\n                    is_stacked=False\n                )\n            )\n            self.fields['followers'] = forms.ModelMultipleChoiceField(\n                queryset=User.objects.all().exclude(pk=self.instance.pk),\n                required=False,\n                widget=FilteredSelectMultiple(\n                    verbose_name='Followers',\n                    is_stacked=False\n                )\n            )\n            self.fields['followers'].initial = self.instance.followers.all()\n</code></pre>\n\n<pre class=\"lang-py prettyprint-override\"><code># project/account/admin.py\nfrom django.contrib.auth import get_user_model\nfrom django.contrib import admin\nfrom django.contrib.auth.models import Group\nfrom django.contrib.auth.admin import UserAdmin as BaseUserAdmin\nfrom .models import User\nfrom .forms import UserChangeForm, UserCreationForm\n\n\nclass Admin(BaseUserAdmin):\n    add_form = UserCreationForm\n    form = UserChangeForm\n    model = get_user_model()\n\n    # The fields to be used in displaying the User model.\n    # These override the definitions on the base UserAdmin\n    # that reference specific fields on auth.User.\n    list_display = ['email', 'username', 'is_admin']\n    list_filter = ('is_admin',)\n    fieldsets = (\n        (None, {'fields': ('email', 'password')}),\n        ('Personal info', {'fields': ('username',)}),\n        ('Permissions', {'fields': ('is_admin', 'is_superuser', 'is_staff')}),\n        # new:\n        ('Following / Followers', {'fields': ('following', 'followers')}),\n    )\n    # other fields\n    # ...\n\n    # new:\n    filter_horizontal = ('following', 'followers')\n\nadmin.site.register(User, Admin)\nadmin.site.unregister(Group)\n</code></pre>\n\n<p>If you then start the server and go to localhost:8000/admin/\nand navigate to a user's detail-page, you should see something like this on your screen:</p>\n\n<p><a href=\"https://i.stack.imgur.com/avr7V.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/avr7V.jpg\" alt=\"enter image description here\"></a></p>\n\n<p>I did not add counters so you are able to see the amount of followers at once in the list_view.</p>\n\n<p><strong>Note</strong> that the second FormField with the followers is read-only in the admin panel. A user cannot choose other users to follow him.</p>\n"}], "is_answered": true, "answer_count": 4, "score": 2, "last_activity_date": 1547216709, "creation_date": 1515718596, "question_id": 48218081, "title": "Django Model ManyToMany Reverse Filter", "body": "<p>Here's excerpts from (something analogous to) my models:</p>\n\n<pre><code>class Person(models.Model):\n  name = models.CharField(max_length=20)\n  relationships = models.ManyToManyField('self',\n    through='Relationship',\n    symmetrical=False,\n    related_name='related_to',\n  )\n  def __str__(self):\n    return self.name\n\nclass Relationship(models.Model):\n  from_person = models.ForeignKey(Person,\n    related_name='from_people',\n    on_delete=models.CASCADE,\n  )\n  to_person = models.ForeignKey(Person,\n    related_name='to_people',\n    on_delete=models.CASCADE,\n  )\n  status = models.CharField(max_length=20)\n  def __str__(self):\n    return \"{} is {} {}\".format(\n      self.from_person.name, self.status, self.to_person.name)\n</code></pre>\n\n<p>Here's the contents of my database:</p>\n\n<pre><code>&gt;&gt;&gt; Person.objects.all()\n&lt;QuerySet [&lt;Person: A&gt;, &lt;Person: B&gt;, &lt;Person: C&gt;]&gt;\n&gt;&gt;&gt; Relationship.objects.all()\n&lt;QuerySet [&lt;Relationship: B is Following C&gt;]&gt;\n</code></pre>\n\n<p>If I want to see who a given person is following, I can build a new method into the Person class:</p>\n\n<pre><code>def get_following(self):\n  return self.relationships.filter(\n    to_people__status='Following',\n    to_people__from_person=self)\n</code></pre>\n\n<p>This works:</p>\n\n<pre><code>&gt;&gt;&gt; p2.get_following()\n&lt;QuerySet [&lt;Person: C&gt;]&gt;\n</code></pre>\n\n<p>I want to do the REVERSE of this.  Instead of asking \"Who does this person follow?\", I want to ask \"Who follows this person?\".  I can do that like this (although it returns Relationship objects, not Person objects):</p>\n\n<pre><code>&gt;&gt;&gt; Relationship.objects.filter(to_person=p3, status='Following')\n&lt;QuerySet [&lt;Relationship: B is Following to C&gt;]&gt;\n</code></pre>\n\n<p>My attempt is this (which returns an empty QuerySet):</p>\n\n<pre><code>def get_following(self):\n  return self.relationships.filter(\n    from_people__status='Following',\n    from_people__to_person=self)\n</code></pre>\n\n<p>Your help is appreciated!</p>\n\n<p>EDIT:\nHere's the ANSWER I chose:</p>\n\n<pre><code>def get_followers(self):\n  return self.related_to.filter(from_people__status='Following')\n</code></pre>\n"}