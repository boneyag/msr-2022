{"tags": ["c#", "json", "linq", "serialization", "odata"], "comments": [{"score": 0, "creation_date": 1407465478, "post_id": 25135061, "comment_id": 39235481, "body": "Can you provide more code like the controller and data model?  And maybe not directly related to your question, $expand is for navigation property but not complex type."}, {"score": 0, "creation_date": 1407486989, "post_id": 25135061, "comment_id": 39242745, "body": "I just send back a DbContext set. The problem is the deserialization in C#, in Javascript we have no problems at all.  return dbContext.Set&lt;Person&gt;()"}], "answers": [{"score": 6, "last_activity_date": 1413755141, "answer_id": 26455753, "question_id": 25135061, "body": "<p>Try deserialize the content like this:</p>\n\n<pre><code>var content = response.Content.ReadAsAsync&lt;ODataResponse&lt;Person&gt;&gt;();\n</code></pre>\n\n<p>Where ODataResponse is:</p>\n\n<pre><code>internal class ODataResponse&lt;T&gt;\n{\n    public T[] Value { get; set; }\n}\n</code></pre>\n"}, {"score": 0, "last_activity_date": 1632848594, "answer_id": 69365828, "question_id": 25135061, "body": "<p>If you need access to the <code>@odata.xxx</code> fields in the response JSON (such as implementing a loop for paged results), the following is my implementation which expands on the solution from andygjp.</p>\n<p>I'm using <a href=\"https://restsharp.dev/\" rel=\"nofollow noreferrer\">RestSharp</a> as my HTTP client and <a href=\"https://www.newtonsoft.com/json\" rel=\"nofollow noreferrer\">Json.NET</a> for (de)serialization. Steps as follows.</p>\n<p>Implement a custom <code>IRestSerializer</code> that uses Json.NET to replace the default RestSharp serializer. Below example implementation:</p>\n<pre><code>public class JsonNetSerializer : IRestSerializer\n{\n    private readonly JsonSerializerSettings _settings;\n\n    public JsonNetSerializer()\n    {\n        _settings = new JsonSerializerSettings\n        {\n            NullValueHandling = NullValueHandling.Ignore\n        };\n        _settings.Converters.Add(new StringEnumConverter());\n    }\n\n    public string Serialize(Parameter parameter) =&gt; JsonConvert.SerializeObject(parameter.Value, Formatting.None, _settings);\n\n    public string Serialize(object obj) =&gt; JsonConvert.SerializeObject(obj, Formatting.None, _settings);\n\n    public T Deserialize&lt;T&gt;(IRestResponse response) =&gt; JsonConvert.DeserializeObject&lt;T&gt;(response.Content);\n\n    public string[] SupportedContentTypes =&gt; new string[] { &quot;application/json&quot;, &quot;text/json&quot;, &quot;text/x-json&quot;, &quot;text/javascript&quot;, &quot;*+json&quot; };\n\n    public DataFormat DataFormat =&gt; DataFormat.Json;\n\n    public string ContentType { get; set; } = &quot;application/json&quot;;\n}\n</code></pre>\n<p>Next, define a class that will represent your OData responses. My expanded response class - which includes the <code>@odata.nextLink</code> field - looks as follows.</p>\n<pre><code>private class ODataResponse&lt;T&gt;\n{\n    public T[] Value { get; set; }\n\n    [JsonProperty(&quot;@odata.nextLink&quot;)]\n    public string NextLink { get; set; }\n}\n</code></pre>\n<p>Finally, I create an instance of <code>RestClient</code>, setting up the custom serializer previously created:</p>\n<pre><code>var client = new RestClient(&quot;https://base.url.here/&quot;)\n    .UseSerializer(() =&gt; new JsonNetSerializer());\n</code></pre>\n<p>Now when I execute my request, the data in the response object object also contains my OData values.</p>\n<pre><code>var response = await client.ExecuteAsync&lt;T&gt;(request);\nvar nextLink = response.Data.NextLink;\n</code></pre>\n<p>I'm sure this can be done using the standard <code>HttpClient</code> instead of RestSharp, as the real work is done by the serializer. This was just the example implementation I had on hand.</p>\n"}], "is_answered": true, "answer_count": 2, "score": 2, "last_activity_date": 1632848594, "creation_date": 1407229869, "question_id": 25135061, "title": "Deserialize Web Api OData response", "body": "<p>I have an Entity Framework object returned by OData V4 controller.\nI return an IQueryable and if I call the OData endpoint without any OData clause I can succesfully do this:</p>\n\n<pre><code>var content = response.Content.ReadAsAsync&lt;IQueryable&lt;Person&gt;&gt;();\n</code></pre>\n\n<p>And the response in JSON is the following:</p>\n\n<pre><code>{\n  \"@odata.context\":\"http://xxx:8082/odata/$metadata#Persons\",\"value\":[\n    {\n      \"Id\":\"291b9f1c-2587-4a35-993e-00033a81f6d5\",\n      \"Active\":true,\n      \"Alert\":\"Some alerts for the Person\",\n      \"Comments\":\"Some comments for the Person\"\n    }\n  ]\n}\n</code></pre>\n\n<p>But as soon as I start to play with OData, for example by using $expand on a Complex property I get the following exception:</p>\n\n<p><strong><em>Cannot deserialize the current JSON object (e.g. {\"name\":\"value\"}) into type 'System.Linq.IQueryable`1[xxx.Person]' because the type requires a JSON array (e.g. [1,2,3]) to deserialize correctly.</em></strong></p>\n\n<p>And the response is the following:</p>\n\n<pre><code>{\n  \"@odata.context\":\"http://aqavnext01:8082/odata/$metadata#Persons\",\"value\":[\n    {\n      \"Id\":\"291b9f1c-2587-4a35-993e-00033a81f6d5\",\n      \"Active\":true,\n      \"Alert\":\"Some alerts for the Person\",\n      \"Comments\":\"Some comments for the Person\",\n      \"Party\":{\n        \"Id\":\"291b9f1c-2587-4a35-993e-00033a81f6d5\"\n      }\n    }\n  ]\n}\n</code></pre>\n\n<p>And I am deserializing using the same object returned by my Web Api so I don't understand why it fails.\nSame issue when I apply $select.</p>\n"}