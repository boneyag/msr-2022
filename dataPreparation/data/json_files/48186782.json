{"tags": ["python", "django"], "answers": [{"comments": [{"score": 0, "creation_date": 1523905116, "post_id": 48187723, "comment_id": 86744205, "body": "<code>whens</code> is a list and you cannot do <code>**whens</code> because it is not a dictionary but a list."}, {"score": 1, "creation_date": 1523997759, "post_id": 48187723, "comment_id": 86790361, "body": "You are correct @user4426017 that it is a list, however I am not expanding it with <code>**whens</code>, I am expanding it with <code>*whens</code> which is what is intended"}, {"score": 1, "creation_date": 1531141694, "post_id": 48187723, "comment_id": 89471277, "body": "Building on what @Omar did, if your dictionary contains variables as key-values, use <code>then=Value(v)</code>. Worked for me."}], "score": 25, "last_activity_date": 1516111904, "last_edit_date": 1516111904, "answer_id": 48187723, "question_id": 48186782, "body": "<p>The closest I've come so far is to loop through the dict and union a whole bunch of filtered query sets based on the dict keys.\nLike so:</p>\n\n<pre><code>value_dict = {\"model1\": 123.4, \"model2\": 567.8}\narray_of_qs = []\nfor k, v in value_dict.items():\n    array_of_qs.append(\n        ModelClass.objects.filter(model__code=k).annotate(value=Value(v))\n    )\nqs = array_of_qs[0].union(*array_of_qs[1:])\n</code></pre>\n\n<p>The qs will then have the result that I want, which is the values of the dict based on the keys of the dict annotated to each instance.</p>\n\n<p>The beauty of this is that there is only one call to the db which is when I decide to use qs, other than that this whole process doesn't touch the DB from what I understand.</p>\n\n<p>Not sure there is a better way yet but will wait to see if there are other responses before accepting this one.</p>\n\n<p><strong>NEW IMPROVED WORKING METHOD BELOW</strong></p>\n\n<p>Unfortunately the above doesn't work with values_list or values as of this current version 1.11 of Django due to this issue:\n<a href=\"https://code.djangoproject.com/ticket/28900\" rel=\"noreferrer\">https://code.djangoproject.com/ticket/28900</a></p>\n\n<p>I devised a cleaner way below:</p>\n\n<pre><code>value_dict = {\"model1\": 123.4, \"model2\": 567.8}\nwhens = [\n    When(model__code=k, then=v) for k, v in value_dict.items()\n]\nqs = ModelClass.objects.all().annotate(\n    value=Case(\n        *whens,\n        default=0,\n        output_field=DecimalField()\n    )\n)\n</code></pre>\n\n<p>Hope it helps someone</p>\n"}], "is_answered": true, "answer_count": 1, "score": 9, "last_activity_date": 1516111904, "creation_date": 1515584795, "question_id": 48186782, "title": "Combining Django F, Value and a dict to annotate a queryset", "body": "<p>I have a scenario where I want to annotate a queryset with externally prepared data in a dict.  I want to do something like the following:</p>\n\n<pre><code>value_dict = {\"model1\": 123.4, \"model2\": 567.8}\nqs = ModelClass.objects.annotate(\n    value=Value(value_dict.get(F('model__code'), 0))\n)\n</code></pre>\n\n<p>The results currently show all as 0 as the F() doesn't seem to be the best way to look up the dict seeing as it doesn't return a string and it is resolved further down the track.</p>\n\n<p>Your help and suggestions would be much appreciated</p>\n\n<p>I'm currently on Python 3.6 and Django 1.11</p>\n"}