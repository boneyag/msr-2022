{"tags": ["python", "django", "manytomanyfield"], "answers": [{"score": 0, "last_activity_date": 1583878295, "answer_id": 60626644, "question_id": 60625639, "body": "<p>I don't think ManyToMany works out of the box.\nSo I had to create a \"through\" model... and change the admin form to this...</p>\n\n<p>models.py</p>\n\n<pre><code>from django.db import models\nfrom django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation\nfrom django.contrib.auth.models import User\nfrom django.utils.html import format_html\nfrom django.contrib.contenttypes.models import ContentType\n\nclass Category(models.Model):\n    class Meta:\n        ordering = ['name']\n\n    name = models.CharField(max_length=100)\n    text = models.TextField(blank=True)\n\n    def __str__(self):\n        return self.name\n\n\n\nclass Tag(models.Model):\n    name = models.CharField(max_length=100)\n    def __str__(self):\n        return self.name\n\nclass Tool(models.Model):\n    name = models.CharField(max_length=30, null=True, default='')   \n    url = models.URLField(max_length=250, null=True, default='')\n    image_url = models.URLField(max_length=250, null=True, default='', blank=True)\n    about = models.TextField(default='', null=True, blank=True)\n    tags = models.ManyToManyField( \n        Tag, \n        through=\"PageTags\",\n        through_fields=('tool', 'tag'))\n\n    category = models.ForeignKey(Category, on_delete=models.CASCADE, blank=True,null=True, related_name=\"category1\")\n    altcategory = models.ForeignKey(Category, on_delete=models.CASCADE, blank=True,null=True, related_name=\"category2\")\n\n    def _get_thumbnail(self):\n        return format_html(u'&lt;img src=\"{}\" width=\"150\"/&gt;', self.image_url)\n    _get_thumbnail.allow_tags = True\n\n    def _get_link(self):\n        return format_html(u'&lt;a href=\"{}\" target=\"_blank\"/&gt;{}&lt;/a&gt;', self.url, self.url)\n    _get_link.allow_tags = True\n\n    def __str__(self):\n        return self.name + \": \" + self.url\n\nclass PageTags(models.Model):\n\n    tag = models.ForeignKey(Tag ,   on_delete=models.CASCADE, )\n    tool= models.ForeignKey(Tool ,  on_delete=models.CASCADE, )\n    amount = models.IntegerField(default=0)\n</code></pre>\n\n<p>... and admin.py to this...</p>\n\n<pre><code>from django.contrib import admin\nfrom django.contrib.admin import TabularInline \n#from django.contrib.contenttypes.admin import  GenericTabularInline\n\nfrom django.utils.html import format_html_join\nfrom django.utils.safestring import mark_safe\n\nfrom .models import Tool, Category, Tag, PageTags\n\n\nclass PageTagsInline(admin.TabularInline): \n    model = PageTags\n    extra = 1\n\n\nclass ToolAdmin(admin.ModelAdmin):\n    #fields = ('name', )\n\n    list_display = ('name','_get_link','category','altcategory', \"_get_thumbnail\", )\n    list_filter = ('category',)\n    search_fields = ['name', \"about\"]\n    filter_horizontal = ('tags',)\n    inlines = [PageTagsInline,]\n\n\nadmin.site.register(Tag)\nadmin.site.register(Category)\nadmin.site.register(Tool, ToolAdmin)\n</code></pre>\n\n<p>And the interface is different, not like the permissions widgets, but OK... at least not bombing the admin.</p>\n"}], "is_answered": false, "answer_count": 1, "score": 0, "last_activity_date": 1583917535, "creation_date": 1583872995, "question_id": 60625639, "title": "ManyToManyField breaking in Admin screens and shouldn&#39;t be", "body": "<p>I have some models like this:</p>\n\n<pre><code>class Category(models.Model):\n    class Meta:\n        ordering = ['name']\n\n    name = models.CharField(max_length=100)\n    text = models.TextField(blank=True)\n\n    def __str__(self):\n        return self.name\n\nclass Tag(models.Model):\n    name = models.CharField(max_length=100)\n    def __str__(self):\n        return self.name\n\nclass Tool(models.Model):\n    name = models.CharField(max_length=30, null=True, default='')   \n    url = models.URLField(max_length=250, null=True, default='')\n    image_url = models.URLField(max_length=250, null=True, default='', blank=True)\n    about = models.TextField(default='', null=True, blank=True)\n    tags = models.ManyToManyField( Tag, related_name=\"tools\" , blank=True)\n    category = models.ForeignKey(Category, on_delete=models.CASCADE, blank=True,null=True, related_name=\"category1\")\n    altcategory = models.ForeignKey(Category, on_delete=models.CASCADE, blank=True,null=True, related_name=\"category2\")\n</code></pre>\n\n<p>And everything seem ok, except when I go to add a tag to a Tool in the Admin screens.\nI can create a Tool and Tag but when I select a tag in the taglist in the Admin screens and Save I get:</p>\n\n<pre><code>The above exception (syntax error at or near \"ON\" LINE 1: ...ls_tool_tags\" (\"tool_id\", \"tag_id\") VALUES (1, 2) ON CONFLIC... ^ ) was the direct cause of the following exception:\n</code></pre>\n\n<p>with the sql:</p>\n\n<pre><code>\n('INSERT INTO \"tools_tool_tags\" (\"tool_id\", \"tag_id\") VALUES (%s, %s) ON '\n 'CONFLICT DO NOTHING')\n\n</code></pre>\n\n<p>The DEBUG screen is saying the error is at \"tag_id\", is strange... </p>\n\n<p>I hope it's not a version thing, since I'm using Heroku and have been really impressed with how everything \"just works\". My Django version is '3.0.4' and Postgres 12.2.</p>\n"}