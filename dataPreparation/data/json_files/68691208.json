{"tags": ["json", "typescript", "eslint", "type-assertion"], "answers": [{"answer_id": 68691267, "question_id": 68691208, "body": "<p><code>JSON.parse</code> isn't generic, so we can't supply a generic argument to do it.</p>\n<p>You have a couple of options.</p>\n<p>The simple thing is that since <code>JSON.parse</code> returns <code>any</code>, you can just define the type of what you're assigning it to:</p>\n<pre class=\"lang-typescript prettyprint-override\"><code>let mqttMessage: MQTTMessage = JSON.parse(message.toString());\n</code></pre>\n<p>(I've used <code>MQTTMessage</code> as a stand-in for the appropriate type.)</p>\n<p>That may not be typesafe enough for everyone, though, since it makes the assumption that the string defines what you expect it to define. And it has the problem that if you do it elsewhere, you repeat the assumption.</p>\n<p>Instead, you could define a function:</p>\n<pre class=\"lang-typescript prettyprint-override\"><code>function parseMQTTMessageJSON(json: string): MQTTMessage {\n    const x: object = JSON.parse(json);\n    if (x &amp;&amp; /*...appropriate checks for properties here...*/&quot;someProp&quot; in x) {\n        return x as MQTTMessage;\n    }\n    throw new Error(`Incorrect JSON for 'MQTTMessage' type`);\n}\n\n</code></pre>\n<p>Then your code is:</p>\n<pre><code>let mqttMessage = parseMQTTMessageJSON(message.toString());\n</code></pre>\n"}, {"answer_id": 68691304, "question_id": 68691208, "body": "<p>The problem is that <code>JSON.parse</code> returns an <code>any</code> type.</p>\n<p>That's fair enough right - TypeScript doesn't know if it's going to parse out to a string, a number, or an object.</p>\n<p>You have a linting rule saying <a href=\"https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-unsafe-assignment.md\" rel=\"nofollow noreferrer\">'Don't allow assigning variables as any</a>'.</p>\n<p>So yeah, you could coerce the result of your JSON.parse</p>\n<pre class=\"lang-js prettyprint-override\"><code>type SomeObjectIKnowAbout = {\n\n}; \nconst result = JSON.parse(message.toString()) as SomeObjectIKnowAbout; \n</code></pre>\n<p>What I tend to like doing in this scenario is create a specific parsing function, that will assert at runtime that the obj really is of the shape you are saying, and will do the type casting to you can treat it while you're writing your code as that object.</p>\n<pre class=\"lang-js prettyprint-override\"><code>type SomeObjectIKnowAbout = {\n    userId: string; \n}\n\ntype ToStringable = {\n    toString: () =&gt; string; \n}\n\nfunction parseMessage(message: ToStringable ) : SomeObjectIKnowAbout {\n    const obj = JSON.parse(message.toString()); //I'm not sure why you are parsing after toStringing tbh. \n\n    if (typeof obj === 'object' &amp;&amp; obj.userId &amp;&amp; typeof obj.userId === 'string') {\n        return obj as SomeObjectIKnowAbout; \n    }\n    else {\n        throw new Error (&quot;message was not a valid SomeObjectIKnowAbout&quot;); \n    }\n}\n\n\n</code></pre>\n"}, {"answer_id": 68697231, "question_id": 68691208, "body": "<p>As an alternative to type assertions and runtime wrapper functions, you can utilize <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-merging.html\" rel=\"nofollow noreferrer\">declaration merging</a> to augment the global <code>JSON</code> object with a generic overload for the <code>parse</code> method. This will allow you to pass through the expected type and give you improved IntelliSense in case you use a <code>reviver</code> when parsing:</p>\n<pre class=\"lang-js prettyprint-override\"><code>interface JSON {\n    parse&lt;T = unknown&gt;(text: string, reviver?: (this: any, key: keyof T &amp; string, value: T[keyof T]) =&gt; unknown): T\n}\n\ntype Test = { a: 1, b: &quot;&quot;, c: false };\n\nconst { a, b, c } = JSON.parse&lt;Test&gt;(\n    &quot;{\\&quot;a\\&quot;:1,\\&quot;b\\&quot;:\\&quot;\\&quot;,\\&quot;c\\&quot;:false}&quot;,  \n    //k is &quot;a&quot;|&quot;b&quot;|&quot;c&quot;, v is false | &quot;&quot; | 1\n    (k,v) =&gt; v\n);\n</code></pre>\n<p>Or, if you are relying on <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html\" rel=\"nofollow noreferrer\">declaration files</a> to augment global interfaces:</p>\n<pre class=\"lang-js prettyprint-override\"><code>declare global {\n  interface JSON {\n    parse&lt;T = unknown&gt;(text: string, reviver?: (this: any, key: keyof T &amp; string, \n  value: T[keyof T]) =&gt; unknown): T\n  }\n}\n</code></pre>\n<hr />\n<p><a href=\"https://www.typescriptlang.org/play?jsx=0&amp;module=1#code/JYOwLgpgTgZghgYwgAgFIGUDyA5ZBvAKGWOQAc4oBnCAHgBVkBeZAVxAGsQB7AdxAD4AFJAAeYAFzJKYKKADmAGmRQIAN2CroAfknCAFsEqS4IAJ5L2EU5MumuMZAwBkUmfKWq4AGxYRJdAG1be0cAXQBKJn5WDm4+cP8CAF8CAjBTUhQ6CGkmfGQ4SQBGJQAjSQAiCqUESXgvamQkgG5UhC4QXLwCspqmvIwcADpyKlps6SEiEgq8AB0KuAXxEoXS5YWFhQWEZfrqJOrp4gB6E-ZkQ2RFioAfCtK7ioRq5FVLymR9lFvriuRfkVjshBOwPJFGNFVARwq0CO1OlwvBAhl4uHJBHBesgELCgA\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}], "is_answered": true, "answer_count": 3, "last_activity_date": 1628387233, "question_id": 68691208, "title": "How to hint the type of a function I do not control?", "body": "<p>When parsing a JSON-formatted string I get a linter error:</p>\n<pre><code>let mqttMessage = JSON.parse(message.toString())\n\n// ESLint: Unsafe assignment of an `any` value. (@typescript-eslint/no-unsafe-assignment)\n</code></pre>\n<p>I control the content of <code>message</code> so I would like to tell TS that what comes out of <code>JSON.parse()</code> is actually an Object. How can I do that?</p>\n<p>Note: I could silence the warning, but I would like to understand if there is a better way to approach the problem.</p>\n"}