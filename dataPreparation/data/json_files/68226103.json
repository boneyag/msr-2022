{
    "tags": [
        "java",
        "regex",
        "java-11",
        "java-16"
    ],
    "answers": [
        {
            "answer_id": 68267216,
            "question_id": 68226103,
            "body": "<p>First, your \u201csymbol <code>\ud946\udc3c</code>\u201d has the codepoint 399420, which is not assigned by the Unicode standard (yet), so if you are seeing something useful here, it\u2019s a non-standard behavior of your system.</p>\n<p>The way you construct the string, is not correct, semantically, but happens to create the intended string. For historic reasons, Java\u2019s API is centered around a UTF-16 representation.</p>\n<p>When you define the symbol using two surrogate characters, i.e.</p>\n<pre><code>var text = &quot;\\uD946\\uDC3C&quot;;\nSystem.out.println(text.codePointAt(0));\n</code></pre>\n<p>you\u2019ll get</p>\n<pre class=\"lang-none prettyprint-override\"><code>399420\n</code></pre>\n<p>On the other hand, when you use</p>\n<pre class=\"lang-java prettyprint-override\"><code>var text = new StringBuilder().appendCodePoint(399420);\ntext.chars().forEach(c -&gt; System.out.printf(&quot;\\\\u%04X&quot;, c));\nSystem.out.println();\n</code></pre>\n<p>you\u2019ll get</p>\n<pre class=\"lang-none prettyprint-override\"><code>\\uD946\\uDC3C\n</code></pre>\n<p>In other words, the sequence of the two surrogate UTF-16 <code>char</code> units <code>\\uD946</code>, <code>\\uDC3C</code> is equivalent to the single codepoint <code>399420</code>. Conceptionally, the string consists of the single codepoint, in other words,</p>\n<pre class=\"lang-java prettyprint-override\"><code>System.out.println(text.codePointCount(0, text.length()) + &quot; codepoint(s)&quot;);\nSystem.out.println(text.codePointAt(0));\nSystem.out.println(&quot;type &quot; + Character.getType(text.codePointAt(0)));\n</code></pre>\n<p>will print</p>\n<pre class=\"lang-none prettyprint-override\"><code>1 codepoint(s)\n399420\ntype 0\n</code></pre>\n<p>in either case. The type <code>0</code> indicates that this codepoint is unassigned.</p>\n<p>You are using <code>appendCodePoint</code> for appending two UTF-16 units to the <code>StringBuilder</code>, but since this method treats codepoints of the <a href=\"https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane\" rel=\"noreferrer\">BMP</a> the same way as UTF-16 units, it happens to construct the same string, too.</p>\n<p>Since the category of the codepoint is \u201cunassigned\u201d, it shouldn\u2019t be \u201csurrogate\u201d, so <code>\\p{Cs}</code> should never find a match here. When processing a valid Unicode string, you should never encounter this category, as it can only match dangling surrogate characters which can not be interpreted as a codepoint outside the <a href=\"https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane\" rel=\"noreferrer\">BMP</a>.</p>\n<p>But there\u2019s the bug <a href=\"https://bugs.openjdk.java.net/browse/JDK-8247546\" rel=\"noreferrer\">JDK-8247546, Pattern matching does not skip correctly over supplementary characters</a>. Before Java\u00a016, the regex engine did process the codepoint at location zero correctly, but advanced only one <code>char</code> position, so it found a dangling surrogate character when looking at <code>char</code> position <code>1</code> alone.</p>\n<p>We can verify it using</p>\n<pre class=\"lang-java prettyprint-override\"><code>var m = Pattern.compile(&quot;\\\\p{Cs}&quot;).matcher(text);\nif(m.find()) {\n    System.out.println(&quot;found a match at &quot; + m.start());\n}\n</code></pre>\n<p>which prints \u201cfound a match at 1\u201d prior to JDK\u00a016, which is wrong, as position <code>1</code> should be skipped when there\u2019s a single codepoint at <code>char</code> positions <code>0</code> and <code>1</code>.</p>\n<p>This bug has been fixed in JDK\u00a016. So now, the string is treated as a single codepoint of the \u201cunassigned\u201d category. Of course, this category might change again in the future. But it should never be \u201csurrogate\u201d.</p>\n"
        }
    ],
    "is_answered": true,
    "answer_count": 1,
    "last_activity_date": 1625570978,
    "question_id": 68226103,
    "title": "Regex \\p{Cs} not matching symbol in Java 16",
    "body": "<p>Does anyone know why the regex <code>\\p{Cs}</code> does not match the symbol <code>\ud946\udc3c</code> in Java 16?\nIt used to match it in Java 11.</p>\n<p>Java 11</p>\n<pre><code>jshell \n|  Welcome to JShell -- Version 11.0.7\n|  For an introduction type: /help intro\n\njshell&gt; import java.util.regex.*\n\njshell&gt; var text = new StringBuilder().appendCodePoint(55622).appendCodePoint(56380)\ntext ==&gt; \ud946\udc3c\n\njshell&gt; Pattern.compile(&quot;\\\\p{Cs}&quot;).matcher(text).find()\n$3 ==&gt; true\n</code></pre>\n<p>Java 16</p>\n<pre><code>INFO: Created user preferences directory.\n|  Welcome to JShell -- Version 16.0.1\n|  For an introduction type: /help intro\n\njshell&gt; import java.util.regex.*\n\njshell&gt; var text = new StringBuilder().appendCodePoint(55622).appendCodePoint(56380)\ntext ==&gt; \ud946\udc3c\n\njshell&gt; Pattern.compile(&quot;\\\\p{Cs}&quot;).matcher(text).find()\n$3 ==&gt; false\n</code></pre>\n"
}