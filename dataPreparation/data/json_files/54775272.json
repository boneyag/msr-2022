{"tags": ["ios", "json", "swift", "codable", "decodable"], "comments": [{"score": 0, "creation_date": 1550647532, "post_id": 54775272, "comment_id": 96340466, "body": "Honestly, I would advise you to move &quot;dynamic&quot; keys into data and use lists instead of objects. It will make your parsing a lot easier and you will get much more structure than a simple <code>[String:Any]</code> which is a casting nightmare. You are trying to do things different from &quot;mainstream&quot; which is generally a Good Thing (TM), but in this case you are producing yourself more trouble than it is worth."}], "answers": [{"comments": [{"score": 0, "creation_date": 1550680135, "post_id": 54776174, "comment_id": 96360260, "body": "Thanks @marcos. That was a mistake from me incorrectly re-creating the production JSON."}], "score": -1, "last_activity_date": 1550616881, "answer_id": 54776174, "question_id": 54775272, "body": "<p>I use this <a href=\"https://app.quicktype.io/\" rel=\"nofollow noreferrer\">https://app.quicktype.io/</a> for help me convert them. \nI checked your output and it is wrong at line :</p>\n\n<pre><code>\"letters\": {\n                \"letterA: \"A\"\n            }\n</code></pre>\n\n<p>The correct : \n<code>\"letterA\": \"A\"</code></p>\n\n<p>In the letterB occur the same one. </p>\n\n<p>Check your output correctly : </p>\n\n<pre><code>{\n    \"groupName\": {\n        \"groupA\": {\n            \"fields\": {\n                \"fieldA\": \"valueA\",\n                \"fieldB\": \"valueB\"\n            },\n            \"letters\": {\n                \"letterA\": \"A\"\n            }\n        },\n        \"groupB\": {\n            \"fields\": {\n                \"fieldC\": \"valueC\",\n                \"fieldD\": \"valueD\"\n            },\n            \"letters\": {\n                \"letterB\": \"B\"\n            }\n        }\n    }\n}\n</code></pre>\n"}, {"comments": [{"score": 0, "creation_date": 1550680073, "post_id": 54776471, "comment_id": 96360217, "body": "Thanks @sandeep. The JSON was just me making a mistake while making sample code, but the real JSON is valid &amp; I should have caught that!"}], "score": 1, "last_activity_date": 1550618719, "answer_id": 54776471, "question_id": 54775272, "body": "<p>You have small mistake in decoding <code>Group</code>. You tend to decode all keys for group inside <code>Group</code> and also you pass further the to decode <code>GroupData</code> which itself has \"fields\" and \"letters\". Use single value container inside <code>Group</code> and it should be fine. </p>\n\n<p>Here is how your <code>Group</code> should look,</p>\n\n<pre><code>struct Group: Decodable {\n    var name: String!\n    var groups: GroupData\n\n    init(from decoder: Decoder) throws {\n        let container = try decoder.singleValueContainer()\n        groups = try container.decode(GroupData.self)\n    }\n}\n</code></pre>\n\n<p>Note, your json itself is incorrect, I have formatted it and it should rather be like this,</p>\n\n<pre><code>let jsonString = \"{\\\"groupName\\\":{\\\"groupA\\\":{\\\"fields\\\":{\\\"fieldA\\\":\\\"valueA\\\",\\\"fieldB\\\":\\\"valueB\\\"},\\\"letters\\\":{\\\"letterA\\\":\\\"A\\\"}},\\\"groupB\\\":{\\\"fields\\\":{\\\"fieldC\\\":\\\"valueC\\\",\\\"fieldD\\\":\\\"valueD\\\"},\\\"letters\\\":{\\\"letterB\\\":\\\"B\\\"}}}}\"\n</code></pre>\n"}], "is_answered": true, "answer_count": 2, "score": 1, "last_activity_date": 1550618719, "creation_date": 1550612101, "question_id": 54775272, "title": "Attempting to parse dynamic JSON in iOS", "body": "<p>I have produced the following sample block of JSON. Any value that ends with a letter is dynamic.</p>\n\n<pre><code>{\n    \"groupName\": {\n        \"groupA\": {\n            \"fields\": {\n                \"fieldA\": \"valueA\",\n                \"fieldB\": \"valueB\"\n            },\n            \"letters\": {\n                \"letterA: \"A\"\n            }\n        },\n        \"groupB\": {\n            \"fields\": {\n                \"fieldC\": \"valueC\",\n                \"fieldD\": \"valueD\"\n            },\n            \"letters\": {\n                \"letterB: \"B\"\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>My goal is to use <code>Decodable</code> so that I may read this data into <code>struct</code>s that I have defined. </p>\n\n<p>Below is my current work contained in a playground file that I am using to try and resolve this:</p>\n\n<pre><code>import Foundation\n\nlet jsonString = \"{\\\"groupName\\\":{\\\"groupA\\\":{\\\"fields\\\":{\\\"fieldA\\\":\\\"valueA\\\",\\\"fieldB\\\":\\\"valueB\\\"},\\\"letters\\\":{\\\"letterA:\\\"A\\\"}},\\\"groupB\\\":{\\\"fields\\\":{\\\"fieldC\\\":\\\"valueC\\\",\\\"fieldD\\\":\\\"valueD\\\"},\\\"letters\\\":{\\\"letterB:\\\"B\\\"}}}}\"\n\nstruct CustomCodingKeys: CodingKey {\n    var intValue: Int?\n    var stringValue: String\n\n    init?(intValue: Int) { self.intValue = intValue; self.stringValue = \"\\(intValue)\" }\n    init?(stringValue: String) { self.stringValue = stringValue }\n\n    static let field = CustomCodingKeys.make(key: \"field\")\n\n    static func make(key: String) -&gt; CustomCodingKeys {\n        return CustomCodingKeys(stringValue: key)!\n    }\n}\n\n// Values\nstruct Field {\n    let field: String\n    let value: String\n}\n\nstruct Letter: Decodable {\n    let title: String\n    let letter: String\n}\n\n// Value holders\nstruct FieldData: Decodable {\n    var fields: [Field]\n\n    init(from decoder: Decoder) throws {\n        self.fields = [Field]()\n        let container = try decoder.container(keyedBy: CustomCodingKeys.self)\n        for key in container.allKeys {\n            print(\"processing field: \\(key.stringValue)\")\n            let dynamicKey = CustomCodingKeys.make(key: key.stringValue)\n            let value = try container.decode(String.self, forKey: dynamicKey)\n            let field = Field(field: key.stringValue,\n                              value: value)\n            fields.append(field)\n        }\n    }\n}\n\nstruct LetterData: Decodable {\n    var letters: [Letter]\n\n    init(from decoder: Decoder) throws {\n        self.letters = [Letter]()\n        let container = try decoder.container(keyedBy: CustomCodingKeys.self)\n        for key in container.allKeys {\n            print(\"processing letter: \\(key.stringValue)\")\n            let dynamicKey = CustomCodingKeys.make(key: key.stringValue)\n            let value = try container.decode(String.self, forKey: dynamicKey)\n            let letter = Letter(title: key.stringValue,\n                                letter: value)\n            letters.append(letter)\n        }\n    }\n}\n\n// Containers\nstruct Group: Decodable {\n    var name: String!\n    var groups: [GroupData]\n\n    init(from decoder: Decoder) throws {\n        self.groups = [GroupData]()\n        let container = try decoder.container(keyedBy: CustomCodingKeys.self)\n        for key in container.allKeys {\n            print(\"processing section: \\(key.stringValue)\")\n            let group = try container.decode(GroupData.self,\n                                             forKey: key)\n            groups.append(group)\n        }\n    }\n}\n\nstruct GroupData: Decodable {\n    var fieldData: FieldData\n    var letterData: LetterData\n\n    enum CodingKeys: String, CodingKey {\n        case fieldData = \"fields\"\n        case letterData = \"letters\"\n    }\n}\n\nstruct GroupList: Decodable {\n    struct GroupName: Decodable {\n        var name: String!\n        var groups: [Group]\n\n        init(from decoder: Decoder) throws {\n            self.groups = [Group]()\n\n            let container = try decoder.container(keyedBy: CustomCodingKeys.self)\n            for key in container.allKeys {\n                let name = key.stringValue\n                self.name = name\n                print(\"processing group: \\(String(describing: self.name))\")\n                var group = try container.decode(Group.self,\n                                                 forKey: key)\n                group.name = name\n                groups.append(group)\n            }\n        }\n    }\n\n    let groupName: GroupName\n}\n\nlet decoder = JSONDecoder()\nif let data = jsonString.data(using: .utf8),\n    let groupList = try? decoder.decode(GroupList.self,\n                                        from: data) {\n    print(\"group list created\")\n}\n</code></pre>\n\n<p>In my <code>GroupData</code> struct, I can drop the variables and then implement <code>init(from decoder: Decoder) throws</code>, which when configured with the proper lookups (the FieldData &amp; LetterData inits), can identify the correct pairs. However, it does not populate the proper value structs.</p>\n"}